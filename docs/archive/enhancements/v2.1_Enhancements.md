# RTPI v2.1 Enhancements: Autonomous Agent Framework

**Created:** January 20, 2026
**Target:** Implement three new autonomous agents with dynamic workflow management
**Dependencies:** Builds on v2.0 infrastructure

---

## Executive Summary

This document details the implementation plan for three new autonomous agents and a dynamic workflow management system that automatically adapts as agents are added or removed:

1. **Tool Connector Agent** - Polls rtpi-tools container to maintain tool registry
2. **Surface Assessment Agent** - Executes BBOT scans against in-scope domains, writes findings to target notes
3. **Web Hacker Agent** - Uses web-hacking tools, nuclei templates, generates custom templates based on findings
4. **Dynamic Workflow Orchestrator** - Manages agent dependencies and adapts workflows automatically

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Dynamic Workflow Orchestrator                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Agent Registry  │  Dependency Graph  │  Capability Matcher     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
        ┌───────────────────────────┼───────────────────────────┐
        ▼                           ▼                           ▼
┌───────────────────┐    ┌───────────────────┐    ┌───────────────────┐
│ Tool Connector    │    │ Surface Assessment│    │ Web Hacker        │
│ Agent             │    │ Agent             │    │ Agent             │
├───────────────────┤    ├───────────────────┤    ├───────────────────┤
│ • Poll rtpi-tools │    │ • Read op scope   │    │ • Read target     │
│ • Update registry │    │ • Execute BBOT    │    │   notes           │
│ • Sync parameters │    │ • Write to target │    │ • Select tools    │
│ • Emit events     │    │   notes           │    │ • Run nuclei      │
└─────────┬─────────┘    └─────────┬─────────┘    │ • Generate        │
          │                        │              │   templates       │
          ▼                        ▼              └─────────┬─────────┘
┌───────────────────┐    ┌───────────────────┐              │
│ Tool Registry     │    │ Target Notes      │◄─────────────┘
│ (toolRegistry)    │    │ (targets.desc)    │
└───────────────────┘    └───────────────────┘
```

---

## Part 1: Dynamic Workflow Orchestrator

### 1.1 Overview

The Dynamic Workflow Orchestrator enables the system to automatically adapt when agents are added, removed, or modified. It uses a capability-based matching system and dependency graph to construct workflows dynamically.

### 1.2 Key Features

- **Capability-based matching**: Agents register capabilities they provide
- **Automatic dependency resolution**: Build execution phases using topological sort
- **Dynamic workflow construction**: Adapt workflows when agents change
- **Event-driven triggers**: Respond to operation events automatically
- **Fallback handling**: Skip/fail/substitute when capabilities are missing

### 1.3 Database Schema Extensions

**File:** `shared/schema.ts`

```typescript
// Agent capability definitions
export const agentCapabilities = pgTable('agent_capabilities', {
  id: uuid('id').primaryKey().defaultRandom(),
  agentId: uuid('agent_id').references(() => agents.id).notNull(),
  capability: varchar('capability', { length: 100 }).notNull(),
  inputTypes: jsonb('input_types').$type<string[]>(),
  outputTypes: jsonb('output_types').$type<string[]>(),
  priority: integer('priority').default(0),
  isEnabled: boolean('is_enabled').default(true),
  metadata: jsonb('metadata').$type<Record<string, any>>(),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

// Workflow templates
export const workflowTemplates = pgTable('workflow_templates', {
  id: uuid('id').primaryKey().defaultRandom(),
  name: varchar('name', { length: 100 }).notNull(),
  description: text('description'),
  triggerEvent: varchar('trigger_event', { length: 100 }),
  requiredCapabilities: jsonb('required_capabilities').$type<string[]>().notNull(),
  optionalCapabilities: jsonb('optional_capabilities').$type<string[]>(),
  configuration: jsonb('configuration').$type<WorkflowTemplateConfig>(),
  isActive: boolean('is_active').default(true),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

// Agent dependencies
export const agentDependencies = pgTable('agent_dependencies', {
  id: uuid('id').primaryKey().defaultRandom(),
  agentId: uuid('agent_id').references(() => agents.id).notNull(),
  dependsOnCapability: varchar('depends_on_capability', { length: 100 }).notNull(),
  dependencyType: varchar('dependency_type', { length: 20 }).notNull(),
  condition: jsonb('condition').$type<DependencyCondition>(),
  createdAt: timestamp('created_at').defaultNow(),
});

// Workflow execution instances
export const workflowInstances = pgTable('workflow_instances', {
  id: uuid('id').primaryKey().defaultRandom(),
  templateId: uuid('template_id').references(() => workflowTemplates.id),
  operationId: uuid('operation_id').references(() => operations.id),
  status: varchar('status', { length: 20 }).default('pending'),
  resolvedAgents: jsonb('resolved_agents').$type<ResolvedAgentNode[]>(),
  executionGraph: jsonb('execution_graph').$type<ExecutionGraph>(),
  currentPhase: integer('current_phase').default(0),
  context: jsonb('context').$type<Record<string, any>>(),
  startedAt: timestamp('started_at'),
  completedAt: timestamp('completed_at'),
  createdAt: timestamp('created_at').defaultNow(),
});
```

### 1.4 Orchestrator Service

**File:** `server/services/dynamic-workflow-orchestrator.ts`

Key methods:
- `refreshCapabilityCache()` - Periodically refresh capability mappings
- `findAgentForCapability()` - Find best agent for a capability
- `buildWorkflow()` - Construct workflow from template
- `buildExecutionGraph()` - Create DAG of agent execution
- `calculatePhases()` - Topological sort for execution order
- `executeWorkflow()` - Run workflow phase by phase
- `registerAgent()` / `unregisterAgent()` - Dynamic agent management

---

## Part 2: Tool Connector Agent

### 2.1 Overview

The Tool Connector Agent autonomously polls the rtpi-tools container to discover available tools, their parameters, and capabilities. It maintains the tool registry in sync with the actual container state.

### 2.2 Agent Configuration

| Property | Value |
|----------|-------|
| **Capabilities** | `tool_discovery`, `tool_registry_sync` |
| **Input Types** | None (runs autonomously) |
| **Output Types** | `tool_list`, `tool_parameters`, `registry_update_event` |
| **Dependencies** | None |
| **Poll Interval** | 5 minutes (configurable) |

### 2.3 Tool Discovery Categories

| Category | Tools |
|----------|-------|
| Reconnaissance | nmap, bbot, amass, subfinder, httpx, katana |
| Vulnerability | nuclei, nikto, wpscan, sqlmap |
| Web | ffuf, gobuster, feroxbuster, dirsearch |
| Network | masscan, rustscan, testssl.sh |
| Exploitation | msfconsole, searchsploit |

### 2.4 Implementation

**File:** `server/services/agents/tool-connector-agent.ts`

Key features:
- Polls container every 5 minutes
- Discovers tool path, version, help text
- Parses command-line parameters automatically
- Syncs to `toolRegistry` and `toolParameters` tables
- Emits events on registry updates

---

## Part 3: Surface Assessment Agent

### 3.1 Overview

The Surface Assessment Agent autonomously retrieves in-scope domains from newly created operations, executes BBOT scans, and writes discovered vulnerabilities to target notes for the Web Hacker Agent to consume.

### 3.2 Agent Configuration

| Property | Value |
|----------|-------|
| **Capabilities** | `scope_retrieval`, `surface_scanning`, `finding_documentation` |
| **Input Types** | `operation_id`, `operation_created_event` |
| **Output Types** | `discovered_assets`, `discovered_vulnerabilities`, `target_notes` |
| **Dependencies** | `tool_discovery` (optional) |

### 3.3 Workflow

```
┌────────────────────┐
│ Operation Created  │
│ (with scope)       │
└─────────┬──────────┘
          │
          ▼
┌────────────────────┐
│ 1. Retrieve Scope  │
│    Parse domains   │
│    from operations │
│    .scope field    │
└─────────┬──────────┘
          │
          ▼
┌────────────────────┐
│ 2. Execute BBOT    │
│    kitchen-sink    │
│    preset with     │
│    --force flag    │
└─────────┬──────────┘
          │
          ▼
┌────────────────────┐
│ 3. Document        │
│    Findings        │
│    - Summary note  │
│    - Individual    │
│      vuln targets  │
└────────────────────┘
```

### 3.4 Output Format

The agent creates a "Surface Assessment Findings" target with markdown content:

```markdown
## Surface Assessment Findings

**Scan Date:** 2026-01-20T12:00:00Z
**Targets Scanned:** example.com, api.example.com
**Duration:** 3600 seconds

### Summary
- **Assets Discovered:** 45
- **Services Found:** 128
- **Vulnerabilities Identified:** 12

### Severity Breakdown
| Severity | Count |
|----------|-------|
| Critical | 2 |
| High | 4 |
| Medium | 4 |
| Low | 2 |

### Top Vulnerabilities
- **SQL Injection in /api/users** (critical) - api.example.com
- **XSS in search parameter** (high) - example.com
```

### 3.5 Implementation

**File:** `server/services/agents/surface-assessment-agent.ts`

Key methods:
- `processOperation()` - Main entry point
- `retrieveScope()` - Get domains from operation.scope
- `executeScan()` - Run BBOT with kitchen-sink preset
- `documentFindings()` - Generate target notes
- `createVulnerabilityTargets()` - Create individual vuln targets

---

## Part 4: Web Hacker Agent

### 4.1 Overview

The Web Hacker Agent consumes vulnerability findings from target notes, selects appropriate tools from the registry, executes nuclei scans with existing templates, and generates custom nuclei templates for discovered vulnerabilities.

### 4.2 Agent Configuration

| Property | Value |
|----------|-------|
| **Capabilities** | `vulnerability_analysis`, `tool_selection`, `nuclei_scanning`, `template_generation` |
| **Input Types** | `target_notes`, `discovered_vulnerabilities`, `tool_list` |
| **Output Types** | `exploitation_results`, `nuclei_templates`, `validated_vulnerabilities` |
| **Dependencies** | `finding_documentation` (required), `tool_discovery` (optional) |

### 4.3 Vulnerability-to-Template Mapping

| Vulnerability Type | Template Paths |
|-------------------|----------------|
| SQL Injection | `vulnerabilities/sqli/`, `cves/` |
| XSS | `vulnerabilities/xss/`, `cves/` |
| SSRF | `vulnerabilities/ssrf/`, `cves/` |
| RCE | `vulnerabilities/rce/`, `cves/` |
| LFI/RFI | `vulnerabilities/lfi/`, `vulnerabilities/rfi/` |
| XXE | `vulnerabilities/xxe/`, `cves/` |
| Auth Bypass | `vulnerabilities/auth-bypass/`, `default-logins/` |
| Info Disclosure | `exposures/`, `misconfiguration/` |

### 4.4 Custom Template Generation

When nuclei doesn't find a matching vulnerability, the agent uses AI to generate a custom template:

```yaml
id: custom-sqli-users-endpoint
info:
  name: SQL Injection in /api/users endpoint
  author: rtpi-web-hacker-agent
  severity: critical
  tags: sqli,custom

http:
  - method: GET
    path:
      - "{{BaseURL}}/api/users?id=1' OR '1'='1"
    matchers:
      - type: word
        words:
          - "error in your SQL syntax"
          - "mysql_fetch"
        condition: or
```

### 4.5 Workflow

```
┌────────────────────────┐
│ Surface Assessment     │
│ Completed Event        │
└──────────┬─────────────┘
           │
           ▼
┌────────────────────────┐
│ 1. Get Vulnerability   │
│    Targets             │
│    (type=vulnerability │
│     status=pending)    │
└──────────┬─────────────┘
           │
           ▼
┌────────────────────────┐
│ 2. Select Templates    │
│    Based on vuln type  │
└──────────┬─────────────┘
           │
           ▼
┌────────────────────────┐
│ 3. Execute Nuclei      │
│    Against target      │
└──────────┬─────────────┘
           │
      ┌────┴────┐
      │ Found?  │
      └────┬────┘
     Yes   │   No
      │    │    │
      ▼    │    ▼
┌──────┐   │  ┌────────────────┐
│Mark  │   │  │4. Generate     │
│Valid │   │  │   Custom       │
└──────┘   │  │   Template     │
           │  └───────┬────────┘
           │          │
           │          ▼
           │  ┌────────────────┐
           │  │5. Re-run Scan  │
           │  │   with Custom  │
           │  └───────┬────────┘
           │          │
           └────┬─────┘
                │
                ▼
       ┌────────────────┐
       │ 6. Update      │
       │    Results     │
       └────────────────┘
```

### 4.6 Implementation

**File:** `server/services/agents/web-hacker-agent.ts`

Key methods:
- `processOperation()` - Main entry point
- `getVulnerabilityTargets()` - Get pending vuln targets
- `selectTemplates()` - Choose nuclei templates
- `executeScan()` - Run nuclei scan
- `generateCustomTemplate()` - AI-powered template generation
- `writeTemplate()` - Save template to container
- `updateOperationSummary()` - Append results to findings

---

## Part 5: Integration Points

### 5.1 Event Flow

```
Operation Created
       │
       ▼
┌──────────────────────────────────────────────────────────────┐
│              Dynamic Workflow Orchestrator                    │
│                                                              │
│  1. Check operation.scope exists                             │
│  2. Build workflow from 'surface-assessment-workflow'        │
│  3. Resolve agents for capabilities                          │
│  4. Execute workflow phases                                  │
└──────────────────────────────────────────────────────────────┘
       │
       ▼
Surface Assessment Agent
       │
       ├── Executes BBOT scan
       ├── Writes findings to target notes
       └── Emits 'operation_completed' event
              │
              ▼
┌──────────────────────────────────────────────────────────────┐
│              Dynamic Workflow Orchestrator                    │
│                                                              │
│  1. Build workflow from 'web-hacker-workflow'                │
│  2. Resolve agents for capabilities                          │
│  3. Execute workflow phases                                  │
└──────────────────────────────────────────────────────────────┘
       │
       ▼
Web Hacker Agent
       │
       ├── Reads vulnerability targets
       ├── Executes nuclei scans
       ├── Generates custom templates
       └── Updates operation summary
```

### 5.2 API Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/v1/agents` | GET | List all registered agents |
| `/api/v1/agents/:id/capabilities` | GET | Get agent capabilities |
| `/api/v1/agents/surface-assessment/trigger` | POST | Manually trigger Surface Assessment |
| `/api/v1/agents/web-hacker/trigger` | POST | Manually trigger Web Hacker |
| `/api/v1/agents/tool-connector/poll` | POST | Manually trigger tool discovery |
| `/api/v1/agents/workflows` | GET | List workflow templates |
| `/api/v1/agents/workflows/:id/status` | GET | Get workflow execution status |
| `/api/v1/agents/workflows/execute` | POST | Execute a workflow |

---

## Part 6: Files to Create

| File | Purpose |
|------|---------|
| `shared/schema.ts` | Add agentCapabilities, workflowTemplates, agentDependencies, workflowInstances tables |
| `server/services/dynamic-workflow-orchestrator.ts` | Dynamic workflow management with capability matching |
| `server/services/agents/tool-connector-agent.ts` | Tool discovery and registry sync |
| `server/services/agents/surface-assessment-agent.ts` | BBOT scanning and finding documentation |
| `server/services/agents/web-hacker-agent.ts` | Nuclei scanning and template generation |
| `server/services/workflow-event-handlers.ts` | Event-driven workflow triggers |
| `server/api/v1/agents.ts` | Agent management API endpoints |
| `server/db/seeds/workflow-templates.ts` | Default workflow template seed data |
| `server/db/migrations/XXXX_agent_capabilities.ts` | Database migration for new tables |

---

## Part 7: Implementation Order

### Week 1: Foundation
1. Add database schema extensions
2. Create database migrations
3. Implement DynamicWorkflowOrchestrator

### Week 2: Tool Connector
4. Implement Tool Connector Agent
5. Add tool registry sync logic
6. Test polling and discovery

### Week 3: Surface Assessment
7. Implement Surface Assessment Agent
8. Integrate with BBOT executor
9. Implement target notes generation

### Week 4: Web Hacker
10. Implement Web Hacker Agent
11. Add template selection logic
12. Implement AI-powered template generation

### Week 5: Integration
13. Create API endpoints
14. Implement event handlers
15. Add workflow templates seed
16. End-to-end testing

---

## Part 8: Success Metrics

- [ ] Tool Connector Agent discovers 20+ tools from rtpi-tools container
- [ ] Surface Assessment Agent completes BBOT scans and writes findings
- [ ] Web Hacker Agent validates vulnerabilities with nuclei
- [ ] AI generates valid nuclei templates for unmatched vulnerabilities
- [ ] Workflow orchestrator handles agent addition/removal gracefully
- [ ] Full pipeline executes in under 4 hours for typical operation

---

## Part 9: Configuration Options

### 9.1 Tool Connector Agent

```typescript
interface ToolConnectorConfig {
  pollIntervalMs: number;        // Default: 300000 (5 minutes)
  containerName: string;          // Default: 'rtpi-tools'
  toolsBasePath: string;          // Default: '/home/rtpi-tools'
  enabledCategories: string[];    // Default: ['reconnaissance', 'vulnerability', 'exploitation', 'web', 'network']
}
```

### 9.2 Surface Assessment Agent

```typescript
interface SurfaceAssessmentConfig {
  defaultBBOTPreset: string;              // Default: 'kitchen-sink'
  defaultBBOTFlags: string[];             // Default: []
  defaultBBOTArgs: string[];              // Default: ['--force', '--allow-deadly']
  maxConcurrentScans: number;             // Default: 3
  autoStartOnOperationCreate: boolean;    // Default: true
  findingNoteTemplate: string;            // Markdown template
}
```

### 9.3 Web Hacker Agent

```typescript
interface WebHackerConfig {
  nucleiTemplatesPath: string;    // Default: '/home/rtpi-tools/nuclei-templates'
  customTemplatesPath: string;    // Default: '/home/rtpi-tools/nuclei-templates/custom'
  maxConcurrentScans: number;     // Default: 5
  aiProvider: 'openai' | 'anthropic';  // Default: 'anthropic'
  aiModel: string;                // Default: 'claude-3-5-sonnet-20241022'
  templateGenerationPrompt: string;  // Custom prompt for template generation
}
```

### 9.4 Workflow Templates

```typescript
interface WorkflowTemplateConfig {
  maxParallelAgents: number;      // Max agents running simultaneously per phase
  timeoutPerPhase: number;        // Timeout in ms per execution phase
  retryPolicy: {
    maxRetries: number;
    backoffMultiplier: number;
  };
  fallbackBehavior: 'skip' | 'fail' | 'substitute';  // Behavior when capability missing
}
```

---

## Part 10: Future Enhancements

### 10.1 Additional Agents (Planned)

- **Report Generation Agent**: Auto-generate PDF/DOCX reports
- **Notification Agent**: Send alerts via email/Slack/webhook
- **Compliance Agent**: Map findings to compliance frameworks
- **Remediation Agent**: Suggest fixes based on vulnerability type

### 10.2 Orchestrator Improvements

- **A/B testing**: Compare agent performance with different configurations
- **Machine learning**: Predict optimal agent selection based on target type
- **Cost optimization**: Track resource usage and optimize execution
- **Audit logging**: Full audit trail of agent decisions and actions
