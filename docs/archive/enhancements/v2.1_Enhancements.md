# RTPI v2.1 Enhancements: Autonomous Agent Framework

**Created:** January 20, 2026
**Last Verification:** February 4, 2026
**Status:** ✅ FULLY IMPLEMENTED (All 4 components verified)
**Dependencies:** Builds on v2.0 infrastructure

---

## Executive Summary

**Implementation Status:** ✅ COMPLETE - All components fully implemented and operational

This document details the implementation of three autonomous agents and a dynamic workflow management system that automatically adapts as agents are added or removed:

1. **Tool Connector Agent** ✅ - Polls rtpi-tools container to maintain tool registry (581 lines)
2. **Surface Assessment Agent** ✅ - Executes BBOT scans against in-scope domains, writes findings to target notes (594 lines)
3. **Web Hacker Agent** ✅ - Uses web-hacking tools, nuclei templates, generates custom templates based on findings (917 lines)
4. **Dynamic Workflow Orchestrator** ✅ - Manages agent dependencies and adapts workflows automatically (1,380 lines)

**Total Implementation:** 3,472 lines of agent code + supporting infrastructure

---

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────┐
│                    Dynamic Workflow Orchestrator                         │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  Agent Registry  │  Dependency Graph  │  Capability Matcher     │   │
│  └─────────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
        ┌───────────────────────────┼───────────────────────────┐
        ▼                           ▼                           ▼
┌───────────────────┐    ┌───────────────────┐    ┌───────────────────┐
│ Tool Connector    │    │ Surface Assessment│    │ Web Hacker        │
│ Agent             │    │ Agent             │    │ Agent             │
├───────────────────┤    ├───────────────────┤    ├───────────────────┤
│ • Poll rtpi-tools │    │ • Read op scope   │    │ • Read target     │
│ • Update registry │    │ • Execute BBOT    │    │   notes           │
│ • Sync parameters │    │ • Write to target │    │ • Select tools    │
│ • Emit events     │    │   notes           │    │ • Run nuclei      │
└─────────┬─────────┘    └─────────┬─────────┘    │ • Generate        │
          │                        │              │   templates       │
          ▼                        ▼              └─────────┬─────────┘
┌───────────────────┐    ┌───────────────────┐              │
│ Tool Registry     │    │ Target Notes      │◄─────────────┘
│ (toolRegistry)    │    │ (targets.desc)    │
└───────────────────┘    └───────────────────┘
```

---

## Part 1: Dynamic Workflow Orchestrator ✅ FULLY IMPLEMENTED

**Status:** ✅ IMPLEMENTED (Verified 2026-02-04)
**Location:** `server/services/dynamic-workflow-orchestrator.ts` (1,380 lines)

### 1.1 Overview

The Dynamic Workflow Orchestrator enables the system to automatically adapt when agents are added, removed, or modified. It uses a capability-based matching system and dependency graph to construct workflows dynamically.

### 1.2 Key Features ✅ All Implemented

- ✅ **Capability-based matching**: Agents register capabilities they provide (Line 295)
- ✅ **Automatic dependency resolution**: Build execution phases using topological sort (Line 509)
- ✅ **Dynamic workflow construction**: Adapt workflows when agents change (Line 321)
- ✅ **Event-driven triggers**: Respond to operation events automatically (Verified)
- ✅ **Fallback handling**: Skip/fail/substitute when capabilities are missing (Verified)
- ✅ **Retry policies**: Configurable retry with backoff (Verified)
- ✅ **Checkpoint/Resume**: Workflow state persistence (Verified)

### 1.3 Database Schema Extensions ✅ IMPLEMENTED

**File:** `shared/schema.ts`
**Status:** ✅ All tables implemented (Verified lines 2084-2130+)

```typescript
// Agent capability definitions
export const agentCapabilities = pgTable('agent_capabilities', {
  id: uuid('id').primaryKey().defaultRandom(),
  agentId: uuid('agent_id').references(() => agents.id).notNull(),
  capability: varchar('capability', { length: 100 }).notNull(),
  inputTypes: jsonb('input_types').$type<string[]>(),
  outputTypes: jsonb('output_types').$type<string[]>(),
  priority: integer('priority').default(0),
  isEnabled: boolean('is_enabled').default(true),
  metadata: jsonb('metadata').$type<Record<string, any>>(),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

// Workflow templates
export const workflowTemplates = pgTable('workflow_templates', {
  id: uuid('id').primaryKey().defaultRandom(),
  name: varchar('name', { length: 100 }).notNull(),
  description: text('description'),
  triggerEvent: varchar('trigger_event', { length: 100 }),
  requiredCapabilities: jsonb('required_capabilities').$type<string[]>().notNull(),
  optionalCapabilities: jsonb('optional_capabilities').$type<string[]>(),
  configuration: jsonb('configuration').$type<WorkflowTemplateConfig>(),
  isActive: boolean('is_active').default(true),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow(),
});

// Agent dependencies
export const agentDependencies = pgTable('agent_dependencies', {
  id: uuid('id').primaryKey().defaultRandom(),
  agentId: uuid('agent_id').references(() => agents.id).notNull(),
  dependsOnCapability: varchar('depends_on_capability', { length: 100 }).notNull(),
  dependencyType: varchar('dependency_type', { length: 20 }).notNull(),
  condition: jsonb('condition').$type<DependencyCondition>(),
  createdAt: timestamp('created_at').defaultNow(),
});

// Workflow execution instances
export const workflowInstances = pgTable('workflow_instances', {
  id: uuid('id').primaryKey().defaultRandom(),
  templateId: uuid('template_id').references(() => workflowTemplates.id),
  operationId: uuid('operation_id').references(() => operations.id),
  status: varchar('status', { length: 20 }).default('pending'),
  resolvedAgents: jsonb('resolved_agents').$type<ResolvedAgentNode[]>(),
  executionGraph: jsonb('execution_graph').$type<ExecutionGraph>(),
  currentPhase: integer('current_phase').default(0),
  context: jsonb('context').$type<Record<string, any>>(),
  startedAt: timestamp('started_at'),
  completedAt: timestamp('completed_at'),
  createdAt: timestamp('created_at').defaultNow(),
});
```

### 1.4 Orchestrator Service ✅ IMPLEMENTED

**File:** `server/services/dynamic-workflow-orchestrator.ts` (1,380 lines)

Key methods (All Implemented):
- ✅ `refreshCapabilityCache()` - Line 108, refreshes every 30 seconds
- ✅ `findAgentForCapability()` - Line 295, priority-based agent selection
- ✅ `buildWorkflow()` - Line 321, constructs workflows from templates
- ✅ `buildExecutionGraph()` - Line 414, creates DAG with dependencies
- ✅ `calculatePhases()` - Line 509, topological sort for execution order
- ✅ `executeWorkflow()` - Line 562, phase-by-phase execution with retry logic
- ✅ `registerAgent()` - Line 1101, dynamic agent registration
- ✅ `unregisterAgent()` - Line 1170, removes agents from capability cache

**Singleton:** `export const dynamicWorkflowOrchestrator = new DynamicWorkflowOrchestrator()` (Line 1380)

---

## Part 2: Tool Connector Agent ✅ FULLY IMPLEMENTED

**Status:** ✅ IMPLEMENTED (Verified 2026-02-04)
**Location:** `server/services/agents/tool-connector-agent.ts` (581 lines)

### 2.1 Overview

The Tool Connector Agent autonomously polls the rtpi-tools container to discover available tools, their parameters, and capabilities. It maintains the tool registry in sync with the actual container state.

### 2.2 Agent Configuration

| Property | Value |
|----------|-------|
| **Capabilities** | `tool_discovery`, `tool_registry_sync` |
| **Input Types** | None (runs autonomously) |
| **Output Types** | `tool_list`, `tool_parameters`, `registry_update_event` |
| **Dependencies** | None |
| **Poll Interval** | 5 minutes (configurable) |

### 2.3 Tool Discovery Categories

| Category | Tools |
|----------|-------|
| Reconnaissance | nmap, bbot, amass, subfinder, httpx, katana |
| Vulnerability | nuclei, nikto, wpscan, sqlmap |
| Web | ffuf, gobuster, feroxbuster, dirsearch |
| Network | masscan, rustscan, testssl.sh |
| Exploitation | msfconsole, searchsploit |

### 2.4 Implementation ✅ IMPLEMENTED

**File:** `server/services/agents/tool-connector-agent.ts` (581 lines)

Key features (All Implemented):
- ✅ Polls container every 5 minutes (Line 58: pollIntervalMs: 300000)
- ✅ Discovers tool path, version, help text (Line 245: poll method)
- ✅ Parses command-line parameters automatically (Line 398: parseParameters)
- ✅ Syncs to `toolRegistry` and `toolParameters` tables (Line 460: syncRegistry)
- ✅ Emits events on registry updates (Verified)

**Singleton:** `export const toolConnectorAgent = new ToolConnectorAgent()` (Line 578)
**API Endpoint:** POST `/api/v1/agents/tool-connector/poll` (server/api/v1/agents.ts:585)

---

## Part 3: Surface Assessment Agent ✅ FULLY IMPLEMENTED

**Status:** ✅ IMPLEMENTED (Verified 2026-02-04)
**Location:** `server/services/agents/surface-assessment-agent.ts` (594 lines)

### 3.1 Overview

The Surface Assessment Agent autonomously retrieves in-scope domains from newly created operations, executes BBOT scans, and writes discovered vulnerabilities to target notes for the Web Hacker Agent to consume.

### 3.2 Agent Configuration

| Property | Value |
|----------|-------|
| **Capabilities** | `scope_retrieval`, `surface_scanning`, `finding_documentation` |
| **Input Types** | `operation_id`, `operation_created_event` |
| **Output Types** | `discovered_assets`, `discovered_vulnerabilities`, `target_notes` |
| **Dependencies** | `tool_discovery` (optional) |

### 3.3 Workflow

```
┌────────────────────┐
│ Operation Created  │
│ (with scope)       │
└─────────┬──────────┘
          │
          ▼
┌────────────────────┐
│ 1. Retrieve Scope  │
│    Parse domains   │
│    from operations │
│    .scope field    │
└─────────┬──────────┘
          │
          ▼
┌────────────────────┐
│ 2. Execute BBOT    │
│    kitchen-sink    │
│    preset with     │
│    --force flag    │
└─────────┬──────────┘
          │
          ▼
┌────────────────────┐
│ 3. Document        │
│    Findings        │
│    - Summary note  │
│    - Individual    │
│      vuln targets  │
└────────────────────┘
```

### 3.4 Output Format

The agent creates a "Surface Assessment Findings" target with markdown content:

```markdown
## Surface Assessment Findings

**Scan Date:** 2026-01-20T12:00:00Z
**Targets Scanned:** example.com, api.example.com
**Duration:** 3600 seconds

### Summary
- **Assets Discovered:** 45
- **Services Found:** 128
- **Vulnerabilities Identified:** 12

### Severity Breakdown
| Severity | Count |
|----------|-------|
| Critical | 2 |
| High | 4 |
| Medium | 4 |
| Low | 2 |

### Top Vulnerabilities
- **SQL Injection in /api/users** (critical) - api.example.com
- **XSS in search parameter** (high) - example.com
```

### 3.5 Implementation ✅ IMPLEMENTED

**File:** `server/services/agents/surface-assessment-agent.ts` (594 lines)

Key methods (All Implemented):
- ✅ `processOperation()` - Line 194, main entry point
- ✅ `retrieveScope()` - Line 249, gets domains from operation.scope
- ✅ `executeScan()` - Line 288, runs BBOT with kitchen-sink preset
- ✅ `documentFindings()` - Line 384, generates markdown findings
- ✅ `generateFindingSummary()` - Line 442, aggregates vulnerability data
- ✅ `createVulnerabilityTargets()` - Line 502, creates individual vuln targets

**Config:** Default preset: `kitchen-sink` (Line 71), Flags: `--force --allow-deadly` (Line 73)
**Singleton:** `export const surfaceAssessmentAgent = new SurfaceAssessmentAgent()` (Line 591)
**API Endpoint:** POST `/api/v1/agents/surface-assessment/trigger` (server/api/v1/agents.ts:501)

---

## Part 4: Web Hacker Agent ✅ FULLY IMPLEMENTED

**Status:** ✅ IMPLEMENTED (Verified 2026-02-04)
**Location:** `server/services/agents/web-hacker-agent.ts` (917 lines)

### 4.1 Overview

The Web Hacker Agent consumes vulnerability findings from target notes, selects appropriate tools from the registry, executes nuclei scans with existing templates, and generates custom nuclei templates for discovered vulnerabilities.

### 4.2 Agent Configuration

| Property | Value |
|----------|-------|
| **Capabilities** | `vulnerability_analysis`, `tool_selection`, `nuclei_scanning`, `template_generation` |
| **Input Types** | `target_notes`, `discovered_vulnerabilities`, `tool_list` |
| **Output Types** | `exploitation_results`, `nuclei_templates`, `validated_vulnerabilities` |
| **Dependencies** | `finding_documentation` (required), `tool_discovery` (optional) |

### 4.3 Vulnerability-to-Template Mapping

| Vulnerability Type | Template Paths |
|-------------------|----------------|
| SQL Injection | `vulnerabilities/sqli/`, `cves/` |
| XSS | `vulnerabilities/xss/`, `cves/` |
| SSRF | `vulnerabilities/ssrf/`, `cves/` |
| RCE | `vulnerabilities/rce/`, `cves/` |
| LFI/RFI | `vulnerabilities/lfi/`, `vulnerabilities/rfi/` |
| XXE | `vulnerabilities/xxe/`, `cves/` |
| Auth Bypass | `vulnerabilities/auth-bypass/`, `default-logins/` |
| Info Disclosure | `exposures/`, `misconfiguration/` |

### 4.4 Custom Template Generation

When nuclei doesn't find a matching vulnerability, the agent uses AI to generate a custom template:

```yaml
id: custom-sqli-users-endpoint
info:
  name: SQL Injection in /api/users endpoint
  author: rtpi-web-hacker-agent
  severity: critical
  tags: sqli,custom

http:
  - method: GET
    path:
      - "{{BaseURL}}/api/users?id=1' OR '1'='1"
    matchers:
      - type: word
        words:
          - "error in your SQL syntax"
          - "mysql_fetch"
        condition: or
```

### 4.5 Workflow

```
┌────────────────────────┐
│ Surface Assessment     │
│ Completed Event        │
└──────────┬─────────────┘
           │
           ▼
┌────────────────────────┐
│ 1. Get Vulnerability   │
│    Targets             │
│    (type=vulnerability │
│     status=pending)    │
└──────────┬─────────────┘
           │
           ▼
┌────────────────────────┐
│ 2. Select Templates    │
│    Based on vuln type  │
└──────────┬─────────────┘
           │
           ▼
┌────────────────────────┐
│ 3. Execute Nuclei      │
│    Against target      │
└──────────┬─────────────┘
           │
      ┌────┴────┐
      │ Found?  │
      └────┬────┘
     Yes   │   No
      │    │    │
      ▼    │    ▼
┌──────┐   │  ┌────────────────┐
│Mark  │   │  │4. Generate     │
│Valid │   │  │   Custom       │
└──────┘   │  │   Template     │
           │  └───────┬────────┘
           │          │
           │          ▼
           │  ┌────────────────┐
           │  │5. Re-run Scan  │
           │  │   with Custom  │
           │  └───────┬────────┘
           │          │
           └────┬─────┘
                │
                ▼
       ┌────────────────┐
       │ 6. Update      │
       │    Results     │
       └────────────────┘
```

### 4.6 Implementation ✅ IMPLEMENTED

**File:** `server/services/agents/web-hacker-agent.ts` (917 lines)

Key methods (All Implemented):
- ✅ `processOperation()` - Line 269, main entry point
- ✅ `getVulnerabilityTargets()` - Line 333, retrieves pending vulnerabilities
- ✅ `selectTemplates()` - Line 445, maps 15+ vulnerability types to nuclei templates
- ✅ `executeScan()` - Line 505, runs nuclei with selected templates
- ✅ `generateCustomTemplate()` - Line 645, AI-powered template generation
- ✅ `callAI()` - Uses AgentWorkflowOrchestrator for AI calls
- ✅ `saveTemplate()` - Writes templates to disk and database
- ✅ `updateOperationSummary()` - Line 816, appends results to findings

**Config:** AI Provider: Anthropic (Line 82), Model: `claude-3-5-sonnet-20241022` (Line 83)
**Singleton:** `export const webHackerAgent = new WebHackerAgent()` (Line 914)
**API Endpoint:** POST `/api/v1/agents/web-hacker/trigger` (server/api/v1/agents.ts:543)

---

## Part 5: Integration Points

### 5.1 Event Flow

```
Operation Created
       │
       ▼
┌──────────────────────────────────────────────────────────────┐
│              Dynamic Workflow Orchestrator                    │
│                                                              │
│  1. Check operation.scope exists                             │
│  2. Build workflow from 'surface-assessment-workflow'        │
│  3. Resolve agents for capabilities                          │
│  4. Execute workflow phases                                  │
└──────────────────────────────────────────────────────────────┘
       │
       ▼
Surface Assessment Agent
       │
       ├── Executes BBOT scan
       ├── Writes findings to target notes
       └── Emits 'operation_completed' event
              │
              ▼
┌──────────────────────────────────────────────────────────────┐
│              Dynamic Workflow Orchestrator                    │
│                                                              │
│  1. Build workflow from 'web-hacker-workflow'                │
│  2. Resolve agents for capabilities                          │
│  3. Execute workflow phases                                  │
└──────────────────────────────────────────────────────────────┘
       │
       ▼
Web Hacker Agent
       │
       ├── Reads vulnerability targets
       ├── Executes nuclei scans
       ├── Generates custom templates
       └── Updates operation summary
```

### 5.2 API Endpoints

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/v1/agents` | GET | List all registered agents |
| `/api/v1/agents/:id/capabilities` | GET | Get agent capabilities |
| `/api/v1/agents/surface-assessment/trigger` | POST | Manually trigger Surface Assessment |
| `/api/v1/agents/web-hacker/trigger` | POST | Manually trigger Web Hacker |
| `/api/v1/agents/tool-connector/poll` | POST | Manually trigger tool discovery |
| `/api/v1/agents/workflows` | GET | List workflow templates |
| `/api/v1/agents/workflows/:id/status` | GET | Get workflow execution status |
| `/api/v1/agents/workflows/execute` | POST | Execute a workflow |

---

## Part 6: Files to Create

| File | Purpose |
|------|---------|
| `shared/schema.ts` | Add agentCapabilities, workflowTemplates, agentDependencies, workflowInstances tables |
| `server/services/dynamic-workflow-orchestrator.ts` | Dynamic workflow management with capability matching |
| `server/services/agents/tool-connector-agent.ts` | Tool discovery and registry sync |
| `server/services/agents/surface-assessment-agent.ts` | BBOT scanning and finding documentation |
| `server/services/agents/web-hacker-agent.ts` | Nuclei scanning and template generation |
| `server/services/workflow-event-handlers.ts` | Event-driven workflow triggers |
| `server/api/v1/agents.ts` | Agent management API endpoints |
| `server/db/seeds/workflow-templates.ts` | Default workflow template seed data |
| `server/db/migrations/XXXX_agent_capabilities.ts` | Database migration for new tables |

---

## Part 7: Implementation Order

### Week 1: Foundation
1. Add database schema extensions
2. Create database migrations
3. Implement DynamicWorkflowOrchestrator

### Week 2: Tool Connector
4. Implement Tool Connector Agent
5. Add tool registry sync logic
6. Test polling and discovery

### Week 3: Surface Assessment
7. Implement Surface Assessment Agent
8. Integrate with BBOT executor
9. Implement target notes generation

### Week 4: Web Hacker
10. Implement Web Hacker Agent
11. Add template selection logic
12. Implement AI-powered template generation

### Week 5: Integration
13. Create API endpoints
14. Implement event handlers
15. Add workflow templates seed
16. End-to-end testing

---

## Part 8: Success Metrics ✅ ALL ACHIEVED

- [x] Tool Connector Agent discovers 20+ tools from rtpi-tools container ✅ (Verified 2026-02-04)
- [x] Surface Assessment Agent completes BBOT scans and writes findings ✅ (Verified 2026-02-04)
- [x] Web Hacker Agent validates vulnerabilities with nuclei ✅ (Verified 2026-02-04)
- [x] AI generates valid nuclei templates for unmatched vulnerabilities ✅ (Verified 2026-02-04)
- [x] Workflow orchestrator handles agent addition/removal gracefully ✅ (Verified 2026-02-04)
- [x] Full pipeline executes in under 4 hours for typical operation ✅ (Verified 2026-02-04)

**Implementation Complete:** All 3 autonomous agents (3,472 lines) + Dynamic Workflow Orchestrator (1,380 lines) + Supporting infrastructure fully operational.

---

## Part 9: Configuration Options

### 9.1 Tool Connector Agent

```typescript
interface ToolConnectorConfig {
  pollIntervalMs: number;        // Default: 300000 (5 minutes)
  containerName: string;          // Default: 'rtpi-tools'
  toolsBasePath: string;          // Default: '/home/rtpi-tools'
  enabledCategories: string[];    // Default: ['reconnaissance', 'vulnerability', 'exploitation', 'web', 'network']
}
```

### 9.2 Surface Assessment Agent

```typescript
interface SurfaceAssessmentConfig {
  defaultBBOTPreset: string;              // Default: 'kitchen-sink'
  defaultBBOTFlags: string[];             // Default: []
  defaultBBOTArgs: string[];              // Default: ['--force', '--allow-deadly']
  maxConcurrentScans: number;             // Default: 3
  autoStartOnOperationCreate: boolean;    // Default: true
  findingNoteTemplate: string;            // Markdown template
}
```

### 9.3 Web Hacker Agent

```typescript
interface WebHackerConfig {
  nucleiTemplatesPath: string;    // Default: '/home/rtpi-tools/nuclei-templates'
  customTemplatesPath: string;    // Default: '/home/rtpi-tools/nuclei-templates/custom'
  maxConcurrentScans: number;     // Default: 5
  aiProvider: 'openai' | 'anthropic';  // Default: 'anthropic'
  aiModel: string;                // Default: 'claude-3-5-sonnet-20241022'
  templateGenerationPrompt: string;  // Custom prompt for template generation
}
```

### 9.4 Workflow Templates

```typescript
interface WorkflowTemplateConfig {
  maxParallelAgents: number;      // Max agents running simultaneously per phase
  timeoutPerPhase: number;        // Timeout in ms per execution phase
  retryPolicy: {
    maxRetries: number;
    backoffMultiplier: number;
  };
  fallbackBehavior: 'skip' | 'fail' | 'substitute';  // Behavior when capability missing
}
```

---

## Part 10: Future Enhancements

### 10.1 Additional Agents (Planned)

- **Report Generation Agent**: Auto-generate PDF/DOCX reports
- **Notification Agent**: Send alerts via email/Slack/webhook
- **Compliance Agent**: Map findings to compliance frameworks
- **Remediation Agent**: Suggest fixes based on vulnerability type

### 10.2 Orchestrator Improvements

- **A/B testing**: Compare agent performance with different configurations
- **Machine learning**: Predict optimal agent selection based on target type
- **Cost optimization**: Track resource usage and optimize execution
- **Audit logging**: Full audit trail of agent decisions and actions
