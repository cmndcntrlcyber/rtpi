# Phase 2: Agent System Architecture - Detailed Plan

Building on **Phase 1's Memory System Foundation**, Phase 2 establishes the agentic operations management framework that enables autonomous task delegation, hourly reporting, and human-in-the-loop decision making.

---

## ğŸ“‹ Phase 2 Overview

**Objective:** Design and implement the multi-agent architecture with Operations Manager orchestration, Reporter Agents, and Task Agents integrated with the Mem0 memory system.

**Duration Estimate:** 7-10 days

**Dependencies:** 
- Phase 1 (Memory System Foundation) MUST be completed first
- Mem0 memory service operational
- Database schema from Phase 1 deployed

---

## ğŸ—ï¸ Architecture Design

### Agent Hierarchy & Roles

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    OPERATIONS MANAGER AGENT                      â”‚
â”‚  (Central Orchestrator - Delegates, Synthesizes, Decides)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                       â”‚
        â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  REPORTER AGENTS â”‚    â”‚   TASK AGENTS    â”‚
â”‚   (Observers)    â”‚    â”‚  (Executors)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                       â”‚
        â”œâ”€ Dashboard Reporter   â”œâ”€ Surface Assessment Agent
        â”œâ”€ Operations Reporter  â”œâ”€ Web Hacker Agent
        â”œâ”€ Targets Reporter     â”œâ”€ Tool Connector Agent
        â”œâ”€ Vulns Reporter       â”œâ”€ Technical Writer Agent
        â”œâ”€ Assets Reporter      â”œâ”€ QA Agent
        â”œâ”€ Tools Reporter       â””â”€ Vulnerability Agent
        â”œâ”€ Workflows Reporter
        â””â”€ Agents Reporter
```

### Agent Communication Protocol

```typescript
// Agent Message Format
interface AgentMessage {
  messageId: string;
  messageType: 'report' | 'task' | 'question' | 'response' | 'alert';
  from: {
    agentId: string;
    agentRole: string;
  };
  to: {
    agentId: string;
    agentRole: string;
  };
  operationId?: string;
  targetId?: string;
  priority: 1 | 2 | 3 | 4 | 5; // 1=Critical, 5=Low
  
  // Content
  content: {
    summary: string;
    data: Record<string, any>;
    context: Record<string, any>;
  };
  
  // Memory integration
  memoryContext: {
    relevantMemories: string[]; // Memory IDs
    shouldStore: boolean;
    memoryType?: 'fact' | 'event' | 'insight' | 'pattern';
  };
  
  // Metadata
  timestamp: Date;
  metadata: Record<string, any>;
}
```

---

## ğŸ¯ Step 2.1: Operations Manager Agent Enhancement

### Core Responsibilities

1. **Task Delegation**
   - Receive hourly reports from Reporter Agents
   - Analyze operational needs
   - Assign tasks to appropriate Task Agents
   - Track task completion

2. **Memory Synthesis**
   - Query Mem0 for relevant operational context
   - Synthesize multi-agent reports into coherent updates
   - Store synthesized insights back to memory

3. **Human-in-the-Loop**
   - Generate questions when uncertain
   - Present decision options to operators
   - Learn from operator responses

4. **Coordination**
   - Resolve conflicts between agents
   - Prioritize competing tasks
   - Manage resource allocation

### Implementation Files

**New/Modified Services:**
```
server/services/operations-manager-agent.ts (ENHANCE EXISTING)
â”œâ”€â”€ Core loops:
â”‚   â”œâ”€â”€ hourlyReportingLoop() - Process reporter submissions
â”‚   â”œâ”€â”€ taskDelegationLoop() - Assign tasks based on needs
â”‚   â”œâ”€â”€ memoryIntegrationLoop() - Sync with Mem0
â”‚   â””â”€â”€ questionManagementLoop() - Handle pending questions
â”‚
â”œâ”€â”€ New methods:
â”‚   â”œâ”€â”€ synthesizeReports(reportIds: string[]): OperationalSummary
â”‚   â”œâ”€â”€ delegateTask(task: TaskDefinition): string
â”‚   â”œâ”€â”€ generateQuestion(context: QuestionContext): Question
â”‚   â”œâ”€â”€ processResponse(questionId: string, answer: string): Action
â”‚   â””â”€â”€ queryMemoryForContext(operationId: string): MemoryContext
â”‚
â””â”€â”€ Integration:
    â””â”€â”€ Uses MemoryService from Phase 1
```

### Database Schema Enhancements

```sql
-- Migration: 0021_enhance_ops_manager.sql

-- Add memory integration to operations
ALTER TABLE operations
ADD COLUMN memory_context_id UUID REFERENCES memory_contexts(id),
ADD COLUMN last_synthesis_at TIMESTAMP,
ADD COLUMN synthesis_summary TEXT;

-- Enhance agent activity reports with memory links
ALTER TABLE agent_activity_reports
ADD COLUMN memory_ids TEXT[] DEFAULT '{}',
ADD COLUMN synthesis_status TEXT DEFAULT 'pending', -- 'pending', 'synthesized', 'archived'
ADD COLUMN synthesized_by_manager_task_id UUID REFERENCES operations_manager_tasks(id);

-- Add memory integration to manager tasks
ALTER TABLE operations_manager_tasks
ADD COLUMN memory_context TEXT[], -- Array of memory IDs used
ADD COLUMN stored_memory_ids TEXT[] DEFAULT '{}', -- New memories created
ADD COLUMN ai_reasoning TEXT; -- AI decision explanation

-- Enhance questions with memory context
ALTER TABLE asset_questions
ADD COLUMN relevant_memory_ids TEXT[] DEFAULT '{}',
ADD COLUMN answer_stored_as_memory_id UUID REFERENCES memory_entries(id);

-- Create indexes for performance
CREATE INDEX idx_operations_memory_context ON operations(memory_context_id);
CREATE INDEX idx_agent_reports_synthesis_status ON agent_activity_reports(synthesis_status);
CREATE INDEX idx_manager_tasks_operation ON operations_manager_tasks(operation_id);
```

---

## ğŸ¯ Step 2.2: Reporter Agent Framework

### Page Reporter Specifications

Each page in RTPI gets its own Reporter Agent that monitors state and reports changes hourly.

```typescript
interface PageReporterConfig {
  reporterId: string;
  pageId: string; // 'dashboard', 'operations', 'targets', 'vulnerabilities', etc.
  pageUrl: string;
  operationId: string;
  
  // Polling configuration
  pollIntervalMs: number; // Default: 3600000 (1 hour)
  changeDetectionEnabled: boolean;
  
  // Memory integration
  memoryEnabled: boolean;
  memoryRetentionDays: number;
  
  // What to monitor
  monitoredMetrics: string[]; // e.g., ['targetCount', 'vulnsBySeverity', 'assetCount']
  changeThreshold: number; // Percentage change to trigger alert
  
  // AI configuration
  aiModel: string;
  aiPromptTemplate: string;
}
```

### Reporter Agent Lifecycle

```
1. INITIALIZATION
   â””â”€> Register reporter â†’ Create memory context â†’ Start polling

2. HOURLY POLL CYCLE
   â”œâ”€> Fetch current page data
   â”œâ”€> Compare with previous snapshot (stored in memory)
   â”œâ”€> Detect changes
   â”œâ”€> Identify issues/anomalies
   â”œâ”€> Generate recommendations
   â”œâ”€> Query memory for historical context
   â”œâ”€> Generate summary using AI
   â””â”€> Submit report to Operations Manager

3. MEMORY STORAGE
   â”œâ”€> Store significant changes as memory 'events'
   â”œâ”€> Store patterns as memory 'insights'
   â””â”€> Create memory relationships (e.g., changeâ†’caused_byâ†’action)

4. QUESTION GENERATION
   â””â”€> If uncertain about change significance â†’ Generate question
```

### Implementation Files

**Enhanced Service:**
```
server/services/reporter-agent-service.ts (ENHANCE EXISTING)
â”œâ”€â”€ integrateWithMemory()
â”‚   â”œâ”€â”€ storeReportInMemory(report: Report): string
â”‚   â”œâ”€â”€ queryRelevantMemories(pageId: string): Memory[]
â”‚   â””â”€â”€ createMemoryRelationships(reportId: string)
â”‚
â”œâ”€â”€ Enhanced pollData()
â”‚   â”œâ”€â”€ Add memory context retrieval
â”‚   â”œâ”€â”€ Add AI-powered change analysis
â”‚   â””â”€â”€ Store insights in Mem0
â”‚
â””â”€â”€ New methods:
    â”œâ”€â”€ generateContextualSummary(data: PageData): string
    â”œâ”€â”€ detectSignificantPatterns(history: PageData[]): Pattern[]
    â””â”€â”€ suggestOperatorActions(changes: Change[]): Action[]
```

**New Reporter Types:**

```typescript
// server/services/reporters/dashboard-reporter.ts
export class DashboardReporter extends BaseReporter {
  async fetchPageData(): PageData {
    // Fetch operation stats, recent activity, critical alerts
  }
  
  detectChanges(prev: PageData, current: PageData): Change[] {
    // Compare operation counts, status changes, alert trends
  }
  
  identifyIssues(data: PageData): Issue[] {
    // No active operations? Stalled workflows? Unanswered questions?
  }
}

// server/services/reporters/targets-reporter.ts
export class TargetsReporter extends BaseReporter {
  async fetchPageData(): PageData {
    // Fetch targets, scan results, discovered services
  }
  
  detectChanges(prev: PageData, current: PageData): Change[] {
    // New targets? Service changes? BBOT output updates?
  }
  
  identifyIssues(data: PageData): Issue[] {
    // Targets without scans? Failed BBOT runs?
  }
}

// server/services/reporters/vulnerabilities-reporter.ts
export class VulnerabilitiesReporter extends BaseReporter {
  async fetchPageData(): PageData {
    // Fetch vulns by severity, unverified findings, remediation status
  }
  
  detectChanges(prev: PageData, current: PageData): Change[] {
    // New vulns? Severity changes? Remediation completed?
  }
  
  identifyIssues(data: PageData): Issue[] {
    // Critical vulns unverified? Missing POCs?
  }
}
```

---

## ğŸ¯ Step 2.3: Agent-to-Agent Communication Layer

### Message Bus Implementation

```typescript
// server/services/agent-message-bus.ts (NEW)
import { EventEmitter } from 'events';

export class AgentMessageBus extends EventEmitter {
  private messageQueue: Map<string, AgentMessage[]> = new Map();
  private agentRegistry: Map<string, AgentInfo> = new Map();
  
  async sendMessage(message: AgentMessage): Promise<void> {
    // Validate message
    // Store in memory if configured
    // Route to recipient
    // Emit event for real-time listeners
  }
  
  async broadcastToRole(role: string, message: AgentMessage): Promise<void> {
    // Send to all agents with matching role
  }
  
  async getMessagesForAgent(agentId: string): Promise<AgentMessage[]> {
    // Retrieve queued messages
  }
  
  async registerAgent(agentInfo: AgentInfo): Promise<void> {
    // Add agent to registry
  }
  
  async unregisterAgent(agentId: string): Promise<void> {
    // Remove from registry
  }
}
```

### Message Storage in Memory

```typescript
// Messages are stored as memory 'events' in Mem0
interface MessageMemory {
  memoryType: 'event';
  messageId: string;
  fromAgent: string;
  toAgent: string;
  messageType: string;
  summary: string; // AI-generated summary
  timestamp: Date;
  contextId: string; // Operation or target ID
}
```

---

## ğŸ¯ Step 2.4: Task Agent Architecture

### Task Agent Base Class

```typescript
// server/services/agents/base-task-agent.ts (NEW)
export abstract class BaseTaskAgent extends EventEmitter {
  protected agentId: string;
  protected agentName: string;
  protected capabilities: string[];
  protected memoryService: MemoryService;
  protected messageBus: AgentMessageBus;
  
  abstract async executeTask(task: TaskDefinition): Promise<TaskResult>;
  
  async reportProgress(taskId: string, progress: number): Promise<void> {
    // Report to Operations Manager
  }
  
  async askQuestion(question: string, context: any): Promise<void> {
    // Send question to Operations Manager
  }
  
  async storeTaskMemory(task: TaskDefinition, result: TaskResult): Promise<void> {
    // Store task execution in Mem0
  }
  
  async getRelevantMemories(taskContext: any): Promise<Memory[]> {
    // Query Mem0 for relevant context
  }
}
```

### Enhanced Existing Task Agents

**Surface Assessment Agent:**
```typescript
// server/services/agents/surface-assessment-agent.ts (ENHANCE)
class SurfaceAssessmentAgent extends BaseTaskAgent {
  async executeTask(task: TaskDefinition): Promise<TaskResult> {
    // 1. Query memory for previous scan results
    const previousScans = await this.getRelevantMemories({
      operationId: task.operationId,
      targetId: task.targetId,
      taskType: 'surface_assessment'
    });
    
    // 2. Execute BBOT/Nuclei/Nmap scans
    const scanResults = await this.runScans(task.parameters);
    
    // 3. Compare with previous results
    const changes = this.detectChanges(previousScans, scanResults);
    
    // 4. Store results in memory
    await this.storeTaskMemory(task, {
      scanResults,
      changes,
      insights: await this.generateInsights(changes)
    });
    
    // 5. Report to Operations Manager
    await this.reportCompletion(task.id, scanResults);
  }
}
```

**Web Hacker Agent:**
```typescript
// server/services/agents/web-hacker-agent.ts (ENHANCE)
class WebHackerAgent extends BaseTaskAgent {
  async executeTask(task: TaskDefinition): Promise<TaskResult> {
    // 1. Query memory for known vulnerabilities on target
    const knownVulns = await this.getRelevantMemories({
      targetId: task.targetId,
      memoryType: 'pattern'
    });
    
    // 2. Generate/select Nuclei templates
    const templates = await this.selectTemplates(task.parameters, knownVulns);
    
    // 3. Execute scans
    const results = await this.runNucleiScans(templates);
    
    // 4. Store findings in memory with relationships
    await this.storeVulnerabilityPatterns(results);
    
    // 5. If CVE-to-Nuclei workflow triggered, create template
    if (task.subtype === 'cve_validation') {
      await this.generateNucleiTemplate(task.parameters.cveId);
    }
  }
}
```

**Technical Writer Agent (NEW):**
```typescript
// server/services/agents/technical-writer-agent.ts (NEW)
export class TechnicalWriterAgent extends BaseTaskAgent {
  async executeTask(task: TaskDefinition): Promise<TaskResult> {
    // 1. Query memory for operation findings
    const findings = await this.memoryService.queryMemories({
      contextType: 'operation',
      contextId: task.operationId,
      memoryType: 'fact'
    });
    
    // 2. Interact with SysReptor CLI/API
    const report = await this.generateReport(findings, task.parameters.template);
    
    // 3. Store report metadata in memory
    await this.storeTaskMemory(task, { reportId: report.id });
    
    return { success: true, reportUrl: report.url };
  }
  
  async generateReport(findings: Memory[], template: string): Promise<Report> {
    // Use SysReptor Python API
  }
}
```

---

## ğŸ¯ Step 2.5: Hourly Reporting Workflow

### Workflow Sequence

```
HOUR 00:00 - Start of reporting cycle
â”œâ”€â”€ [00:00-00:05] Reporter Agents poll their pages
â”‚   â”œâ”€> Dashboard Reporter â†’ Fetches operation stats
â”‚   â”œâ”€> Operations Reporter â†’ Fetches operation details
â”‚   â”œâ”€> Targets Reporter â†’ Fetches targets & services
â”‚   â”œâ”€> Vulnerabilities Reporter â†’ Fetches vuln stats
â”‚   â””â”€> ... (other reporters)
â”‚
â”œâ”€â”€ [00:05-00:10] Reporter Agents analyze & generate reports
â”‚   â”œâ”€> Detect changes from previous hour
â”‚   â”œâ”€> Identify issues
â”‚   â”œâ”€> Query memory for context
â”‚   â”œâ”€> Generate AI summary
â”‚   â””â”€> Submit report to Operations Manager
â”‚
â”œâ”€â”€ [00:10-00:20] Operations Manager synthesizes reports
â”‚   â”œâ”€> Receive all reports
â”‚   â”œâ”€> Query memory for operation context
â”‚   â”œâ”€> Use AI to synthesize multi-agent reports
â”‚   â”œâ”€> Identify patterns across reports
â”‚   â”œâ”€> Generate consolidated summary
â”‚   â””â”€> Store synthesis in memory
â”‚
â”œâ”€â”€ [00:20-00:30] Operations Manager generates tasks/questions
â”‚   â”œâ”€> If new targets discovered â†’ Assign Surface Assessment task
â”‚   â”œâ”€> If CVEs found â†’ Assign Nuclei template generation task
â”‚   â”œâ”€> If data ambiguous â†’ Generate question for operator
â”‚   â””â”€> Store task assignments in memory
â”‚
â”œâ”€â”€ [00:30-00:45] Task Agents execute assigned tasks
â”‚   â”œâ”€> Surface Assessment Agent â†’ Run BBOT/Nuclei
â”‚   â”œâ”€> Web Hacker Agent â†’ Execute Nuclei templates
â”‚   â””â”€> Report completion back to Operations Manager
â”‚
â””â”€â”€ [00:45-00:59] Operations Manager updates operation status
    â”œâ”€> Update operation.managementStatus
    â”œâ”€> Store hourly summary in memory
    â””â”€> Wait for next hour
```

### Implementation

```typescript
// server/services/hourly-ops-workflow.ts (NEW)
export class HourlyOpsWorkflow {
  private scheduler: NodeSchedule;
  private opsManager: OperationsManagerAgent;
  private reporterService: ReporterAgentService;
  private memoryService: MemoryService;
  
  start(): void {
    // Run at the start of every hour
    this.scheduler = schedule.scheduleJob('0 * * * *', async () => {
      await this.executeHourlyCycle();
    });
  }
  
  private async executeHourlyCycle(): Promise<void> {
    const operations = await this.getActiveOperations();
    
    for (const operation of operations) {
      if (!operation.hourlyReportingEnabled) continue;
      
      try {
        // Step 1: Trigger all reporters
        await this.triggerReporters(operation.id);
        
        // Step 2: Wait for reports (5 minutes)
        await this.waitForReports(operation.id);
        
        // Step 3: Synthesize reports
        const synthesis = await this.opsManager.synthesizeReports(operation.id);
        
        // Step 4: Generate tasks/questions
        await this.opsManager.processOperationalNeeds(operation.id, synthesis);
        
        // Step 5: Execute tasks
        await this.executeGeneratedTasks(operation.id);
        
      } catch (error) {
        console.error(`Hourly workflow failed for operation ${operation.id}:`, error);
      }
    }
  }
}
```

---

## ğŸ¯ Step 2.6: Human-in-the-Loop Q&A System

### Question Generation

```typescript
interface QuestionContext {
  operationId: string;
  assetId?: string;
  triggerEvent: string; // 'new_asset', 'ambiguous_data', 'classification_needed'
  relevantData: any;
  suggestedAnswers?: string[]; // Multiple choice options
}

interface GeneratedQuestion {
  question: string;
  questionType: 'context' | 'scope' | 'priority' | 'classification' | 'verification';
  priority: number;
  context: QuestionContext;
  aiReasoning: string; // Why this question was asked
}
```

### Question Workflow

```
1. QUESTION GENERATION
   â””â”€> Operations Manager detects ambiguity â†’ Generates question

2. QUESTION PRESENTATION
   â””â”€> Displayed in Operations Manager chat window (UI)

3. OPERATOR RESPONSE
   â””â”€> Operator provides answer â†’ Stored in memory

4. TASK GENERATION (Optional)
   â””â”€> Operations Manager converts answer to actionable task

5. MEMORY STORAGE
   â””â”€> Answer stored as memory 'fact' with relationships
```

### API Endpoints

```typescript
// server/api/v1/operations-manager.ts (ENHANCE)
router.get('/questions/pending', async (req, res) => {
  // Get pending questions for current operation
});

router.post('/questions/:id/respond', async (req, res) => {
  // Operator submits answer
  const { questionId } = req.params;
  const { answer, generateTask } = req.body;
  
  await opsManager.respondToQuestion(questionId, answer, generateTask);
});

router.post('/questions/:id/dismiss', async (req, res) => {
  // Dismiss question as not relevant
});

router.get('/synthesis/:operationId', async (req, res) => {
  // Get latest hourly synthesis summary
});
```

---

## ğŸ¯ Step 2.7: Integration with Memory System (Phase 1)

### Memory Context Mapping

```typescript
// Each operation gets a memory context
const operationMemoryContext = {
  contextType: 'operation',
  contextId: operation.id,
  contextName: operation.name
};

// Memory entry types stored:
// 1. FACTS - Discovered assets, services, vulnerabilities
// 2. EVENTS - Scans executed, tasks completed, reports generated
// 3. INSIGHTS - Patterns detected, anomalies identified
// 4. PATTERNS - Recurring issues, successful techniques
```

### Memory Query Patterns

```typescript
// Operations Manager queries memory for context
const relevantMemories = await memoryService.queryMemories({
  contextId: operation.id,
  memoryTypes: ['fact', 'insight', 'pattern'],
  timeRange: { hours: 24 }, // Last 24 hours
  relevanceScore: { min: 0.7 } // High relevance only
});

// Reporter Agent queries previous states
const previousState = await memoryService.queryMemories({
  contextId: operation.id,
  source: 'targets_reporter',
  memoryType: 'event',
  limit: 1,
  orderBy: 'created_at DESC'
});

// Task Agent queries similar tasks
const similarTasks = await memoryService.searchSimilar({
  text: taskDescription,
  memoryType: 'event',
  limit: 5
});
```

---

## ğŸ“¦ Step 2.8: Deliverables

### Implementation Files

1. **Agent Services (New/Enhanced)**
   ```
   server/services/operations-manager-agent.ts (ENHANCE)
   server/services/reporter-agent-service.ts (ENHANCE)
   server/services/agent-message-bus.ts (NEW)
   server/services/agents/base-task-agent.ts (NEW)
   server/services/agents/technical-writer-agent.ts (NEW)
   server/services/agents/qa-agent.ts (NEW)
   server/services/agents/target-agent.ts (NEW)
   server/services/agents/vulnerability-agent.ts (NEW)
   server/services/hourly-ops-workflow.ts (NEW)
   ```

2. **Reporter Implementations**
   ```
   server/services/reporters/dashboard-reporter.ts (NEW)
   server/services/reporters/operations-reporter.ts (NEW)
   server/services/reporters/targets-reporter.ts (NEW)
   server/services/reporters/vulnerabilities-reporter.ts (NEW)
   server/services/reporters/assets-reporter.ts (NEW)
   server/services/reporters/tools-reporter.ts (NEW)
   server/services/reporters/workflows-reporter.ts (NEW)
   server/services/reporters/agents-reporter.ts (NEW)
   ```

3. **API Routes**
   ```
   server/api/v1/operations-manager.ts (ENHANCE)
   server/api/v1/reporters.ts (NEW)
   server/api/v1/agent-messages.ts (NEW)
   ```

4. **Database Migrations**
   ```
   migrations/0021_enhance_ops_manager.sql
   migrations/0022_add_reporter_memory_integration.sql
   ```

5. **Documentation**
   ```
   docs/enhancements/2.3/agent-architecture.md
   docs/enhancements/2.3/reporter-agent-guide.md
   docs/enhancements/2.3/operations-manager-workflow.md
   docs/enhancements/2.3/agent-communication-protocol.md
   ```

6. **Configuration**
   ```
   server/config/agent-config.ts (NEW)
   server/config/reporter-config.ts (NEW)
   ```

7. **Tests**
   ```
   tests/unit/operations-manager-agent.test.ts
   tests/unit/reporter-agents.test.ts
   tests/unit/agent-message-bus.test.ts
   tests/integration/hourly-workflow.test.ts
   tests/integration/memory-agent-integration.test.ts
   ```

---

## âœ… Step 2.9: Success Criteria

- [ ] Operations Manager Agent enhanced with memory integration
- [ ] 8 Reporter Agents implemented and operational
- [ ] Agent Message Bus functional
- [ ] Hourly reporting workflow operational
- [ ] Question/Answer system integrated
- [ ] Task delegation system working
- [ ] Memory integration verified (queries, storage, relationships)
- [ ] All agents can communicate via message bus
- [ ] Technical Writer Agent integrated with SysReptor
- [ ] Database schema migrations applied
- [ ] API endpoints tested and documented
- [ ] Unit tests passing (>80% coverage)
- [ ] Integration tests passing
- [ ] Documentation complete

---

## ğŸ¯ Implementation Order (Baby Stepsâ„¢)

1. **Database Schema** (Day 1)
   - Migration 0021: Enhance ops manager tables
   - Migration 0022: Add reporter memory integration

2. **Agent Message Bus** (Day 2)
   - Implement message routing
   - Test agent registration
   - Verify message delivery

3. **Base Task Agent** (Day 2-3)
   - Create abstract base class
   - Implement memory integration methods
   - Test with existing Surface Assessment Agent

4. **Reporter Framework** (Day 3-4)
   - Enhance reporter service with memory
   - Implement base reporter logic
   - Test with Dashboard Reporter

5. **Individual Reporters** (Day 4-5)
   - Implement 8 page reporters
   - Test polling and change detection

6. **Operations Manager Enhancement** (Day 6-7)
   - Add synthesis logic
   - Implement task delegation
   - Add question generation

7. **Hourly Workflow** (Day 7-8)
   - Implement scheduling
   - Test full cycle
   - Verify memory storage

8. **Q&A System** (Day 8-9)
   - API endpoints
   - Question storage
   - Response processing

9. **Task Agents** (Day 9-10)
   - Technical Writer Agent
   - QA Agent
   - Vulnerability Agent
   - Target Agent

10. **Testing & Documentation** (Day 10)
    - Integration tests
    - Documentation
    - Final verification

---

## ğŸš€ Ready to Proceed?

This plan establishes the complete agent architecture that enables:
- **Autonomous hourly reporting** from page observers
- **Intelligent task delegation** by Operations Manager
- **Memory-enhanced decision making** using Mem0
- **Human-in-the-loop** question/answer workflow
- **Multi-agent coordination** via message bus

**Next Steps:**
1. Review this Phase 2 plan
2. Confirm scope and priorities
3. Toggle to Act mode to begin implementation

Would you like me to proceed with Phase 2 implementation, or would you prefer to adjust this plan first?