import { Router } from "express";
import { db } from "../../db";
import {
  vulnerabilities,
  researchProjects,
  rdExperiments,
  targets
} from "@shared/schema";
import { eq, desc } from "drizzle-orm";
import { ensureAuthenticated, ensureRole, logAudit } from "../../auth/middleware";
import { z } from "zod";

const router = Router();
router.use(ensureAuthenticated);

// Request schema for sending vulnerability to R&D
const sendToRDSchema = z.object({
  vulnerabilityId: z.string().uuid(),
  projectName: z.string().optional(),
  leadAgentId: z.string().uuid().optional(),
  includeResearchPhase: z.boolean().default(true),
  includePocPhase: z.boolean().default(true),
  includeNucleiPhase: z.boolean().default(true),
});

// POST /api/v1/vulnerability-rd/send-to-rd
// Creates a research project with experiments for vulnerability research
router.post("/send-to-rd", ensureRole("admin", "operator"), async (req, res) => {
  const user = req.user as any;

  try {
    const data = sendToRDSchema.parse(req.body);

    // 1. Fetch the vulnerability details
    const [vuln] = await db
      .select()
      .from(vulnerabilities)
      .where(eq(vulnerabilities.id, data.vulnerabilityId))
      .limit(1);

    if (!vuln) {
      return res.status(404).json({ error: "Vulnerability not found" });
    }

    // Fetch associated target if exists
    let targetInfo = null;
    if (vuln.targetId) {
      const [target] = await db
        .select()
        .from(targets)
        .where(eq(targets.id, vuln.targetId))
        .limit(1);
      targetInfo = target;
    }

    // 2. Create the research project
    const projectName = data.projectName ||
      `R&D: ${vuln.title}${vuln.cveId ? ` (${vuln.cveId})` : ''}`;

    const projectDescription = `## Vulnerability Research Project

**Source:** ${vuln.title}
${vuln.cveId ? `**CVE:** ${vuln.cveId}` : ''}
${vuln.cweId ? `**CWE:** ${vuln.cweId}` : ''}
**Severity:** ${vuln.severity}
${vuln.cvssScore ? `**CVSS Score:** ${(vuln.cvssScore / 10).toFixed(1)}` : ''}

### Original Description
${vuln.description || 'No description provided'}

### Target Information
${targetInfo ? `- **Target:** ${targetInfo.name} (${targetInfo.type}: ${targetInfo.value})` : 'No target associated'}`;

    const objectives = `1. Research and understand the vulnerability exploitation vectors
2. Develop a working Proof of Concept (POC)
3. Create a Nuclei template for automated detection
4. Document findings and mitigation strategies`;

    const successCriteria = `- [ ] Vulnerability exploitation method documented
- [ ] Working POC developed and tested
- [ ] Nuclei template created and validated
- [ ] Detection and mitigation guidance provided`;

    const [project] = await db
      .insert(researchProjects)
      .values({
        name: projectName,
        description: projectDescription,
        type: "vulnerability_research",
        status: "active",
        sourceVulnerabilityId: vuln.id,
        leadAgentId: data.leadAgentId || null,
        objectives,
        successCriteria,
        createdBy: user.id,
        artifacts: [],
        assignedAgents: [],
        findings: {},
      })
      .returning();

    // 3. Create linked experiments based on phases
    const experiments: Array<{ phase: string; experiment: any }> = [];

    if (data.includeResearchPhase) {
      const [researchExp] = await db
        .insert(rdExperiments)
        .values({
          projectId: project.id,
          name: `Research: ${vuln.title}`,
          description: "Deep-dive research into vulnerability mechanics and exploitation vectors",
          hypothesis: `The vulnerability "${vuln.title}" can be exploited using known attack patterns for ${vuln.cweId || 'this class of vulnerability'}`,
          methodology: `1. Analyze vulnerability description and references
2. Research known exploitation techniques
3. Identify attack vectors and prerequisites
4. Document exploitation methodology`,
          toolsUsed: ["web-browser", "documentation-tools"],
          targets: targetInfo ? [{ id: targetInfo.id, name: targetInfo.name, value: targetInfo.value }] : [],
          status: "planned",
          results: {},
        })
        .returning();
      experiments.push({ phase: "research", experiment: researchExp });
    }

    if (data.includePocPhase) {
      const [pocExp] = await db
        .insert(rdExperiments)
        .values({
          projectId: project.id,
          name: `POC Development: ${vuln.title}`,
          description: "Develop a working Proof of Concept for the vulnerability",
          hypothesis: "A reliable POC can be developed to demonstrate the vulnerability",
          methodology: `1. Set up test environment
2. Implement exploitation logic
3. Test and refine POC
4. Document usage instructions`,
          toolsUsed: ["code-editor", "testing-framework"],
          targets: targetInfo ? [{ id: targetInfo.id, name: targetInfo.name, value: targetInfo.value }] : [],
          status: "planned",
          results: {},
        })
        .returning();
      experiments.push({ phase: "poc", experiment: pocExp });
    }

    if (data.includeNucleiPhase) {
      const [nucleiExp] = await db
        .insert(rdExperiments)
        .values({
          projectId: project.id,
          name: `Nuclei Template: ${vuln.title}`,
          description: "Create a Nuclei scan template for automated vulnerability detection",
          hypothesis: "A Nuclei template can reliably detect this vulnerability in target systems",
          methodology: `1. Analyze POC to identify detection signatures
2. Write Nuclei template YAML
3. Test template against known-vulnerable targets
4. Validate false positive/negative rates`,
          toolsUsed: ["nuclei", "yaml-editor"],
          targets: targetInfo ? [{ id: targetInfo.id, name: targetInfo.name, value: targetInfo.value }] : [],
          status: "planned",
          results: {},
        })
        .returning();
      experiments.push({ phase: "nuclei", experiment: nucleiExp });
    }

    // 4. Audit log
    await logAudit(
      user.id,
      "vulnerability_send_to_rd",
      "/vulnerability-rd/send-to-rd",
      project.id,
      true,
      req
    );

    res.status(201).json({
      success: true,
      project,
      experiments,
      message: `Research project created with ${experiments.length} experiments`,
    });

  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ error: "Validation failed", details: error.errors });
    }
    console.error("Send to R&D failed:", error);
    res.status(500).json({ error: "Failed to create R&D project", details: error.message });
  }
});

// GET /api/v1/vulnerability-rd/:vulnerabilityId/projects
// Check if R&D projects exist for a vulnerability
router.get("/:vulnerabilityId/projects", async (req, res) => {
  const { vulnerabilityId } = req.params;

  try {
    const projects = await db
      .select()
      .from(researchProjects)
      .where(eq(researchProjects.sourceVulnerabilityId, vulnerabilityId))
      .orderBy(desc(researchProjects.createdAt));

    res.json({ projects });
  } catch (error: any) {
    res.status(500).json({ error: "Failed to fetch R&D projects", details: error.message });
  }
});

export default router;
