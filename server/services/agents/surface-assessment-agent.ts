/**
 * Surface Assessment Agent
 *
 * Autonomously retrieves in-scope domains from newly created operations,
 * executes BBOT scans, and writes discovered vulnerabilities to target notes
 * for the Web Hacker Agent to consume.
 *
 * Capabilities:
 * - scope_retrieval: Retrieve in-scope domains from operation
 * - surface_scanning: Execute BBOT reconnaissance
 * - finding_documentation: Write findings to target notes
 */

import { db } from '../../db';
import {
  agents,
  operations,
  targets,
  vulnerabilities,
  discoveredAssets,
  discoveredServices,
  axScanResults,
} from '../../../shared/schema';
import { BBOTExecutor } from '../bbot-executor';
import { eq, and } from 'drizzle-orm';
import { EventEmitter } from 'events';

// ============================================================================
// Types
// ============================================================================

export interface SurfaceAssessmentConfig {
  defaultBBOTPreset: string;
  defaultBBOTFlags: string[];
  defaultBBOTArgs: string[];
  maxConcurrentScans: number;
  autoStartOnOperationCreate: boolean;
  findingNoteTemplate: string;
}

export interface ScanResult {
  operationId: string;
  scanId: string;
  targets: string[];
  assetsFound: number;
  servicesFound: number;
  vulnerabilitiesFound: number;
  duration: number;
  status: 'completed' | 'failed';
}

export interface FindingSummary {
  totalAssets: number;
  totalServices: number;
  totalVulnerabilities: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  topVulnerabilities: Array<{
    title: string;
    severity: string;
    affectedAsset: string;
  }>;
}

// ============================================================================
// Default Configuration
// ============================================================================

const DEFAULT_CONFIG: SurfaceAssessmentConfig = {
  defaultBBOTPreset: 'kitchen-sink',
  defaultBBOTFlags: [],
  defaultBBOTArgs: ['--force', '--allow-deadly'],
  maxConcurrentScans: 3,
  autoStartOnOperationCreate: true,
  findingNoteTemplate: `
## Surface Assessment Findings

**Scan Date:** {{scanDate}}
**Targets Scanned:** {{targets}}
**Duration:** {{duration}}

### Summary
- **Assets Discovered:** {{totalAssets}}
- **Services Found:** {{totalServices}}
- **Vulnerabilities Identified:** {{totalVulnerabilities}}

### Severity Breakdown
| Severity | Count |
|----------|-------|
| Critical | {{criticalCount}} |
| High | {{highCount}} |
| Medium | {{mediumCount}} |
| Low | {{lowCount}} |

### Top Vulnerabilities
{{#vulnerabilities}}
- **{{title}}** ({{severity}}) - {{affectedAsset}}
{{/vulnerabilities}}

---
*Generated by Surface Assessment Agent*
`,
};

// ============================================================================
// Surface Assessment Agent
// ============================================================================

export class SurfaceAssessmentAgent extends EventEmitter {
  private config: SurfaceAssessmentConfig;
  private bbotExecutor: BBOTExecutor;
  private activeScans: Map<string, string> = new Map(); // operationId -> scanId
  private agentId: string | null = null;

  constructor(config: Partial<SurfaceAssessmentConfig> = {}) {
    super();
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.bbotExecutor = new BBOTExecutor();
  }

  /**
   * Initialize the agent
   */
  async initialize(): Promise<void> {
    // Check if agent exists, create if not
    const [existingAgent] = await db
      .select()
      .from(agents)
      .where(eq(agents.name, 'Surface Assessment Agent'));

    if (existingAgent) {
      this.agentId = existingAgent.id;
      console.log(`Surface Assessment Agent found: ${this.agentId}`);
    } else {
      const [newAgent] = await db
        .insert(agents)
        .values({
          name: 'Surface Assessment Agent',
          type: 'custom',
          status: 'idle',
          config: {
            handlerPath: './agents/surface-assessment-agent',
            ...this.config,
          },
          capabilities: ['scope_retrieval', 'surface_scanning', 'finding_documentation'],
        })
        .returning();
      this.agentId = newAgent.id;
      console.log(`Surface Assessment Agent created: ${this.agentId}`);
    }

    // Register with dynamic workflow orchestrator
    try {
      const { dynamicWorkflowOrchestrator } = await import('../dynamic-workflow-orchestrator');
      await dynamicWorkflowOrchestrator.registerAgent(
        this.agentId,
        [
          {
            capability: 'scope_retrieval',
            inputTypes: ['operation_id'],
            outputTypes: ['domain_list', 'scope_config'],
            priority: 10,
          },
          {
            capability: 'surface_scanning',
            inputTypes: ['domain_list'],
            outputTypes: ['discovered_assets', 'discovered_services', 'discovered_vulnerabilities'],
            priority: 10,
          },
          {
            capability: 'finding_documentation',
            inputTypes: ['discovered_vulnerabilities'],
            outputTypes: ['target_notes'],
            priority: 10,
          },
        ],
        [
          {
            dependsOnCapability: 'tool_discovery',
            type: 'optional',
          },
        ]
      );
      console.log('Surface Assessment Agent registered with orchestrator');
    } catch (error) {
      console.warn('Could not register with orchestrator:', error);
    }
  }

  /**
   * Process an operation - main entry point
   */
  async processOperation(operationId: string, userId: string): Promise<ScanResult> {
    console.log(`Surface Assessment Agent: Processing operation ${operationId}`);
    this.emit('operation_started', operationId);

    // Update agent status
    await this.updateAgentStatus('running');

    try {
      // Step 1: Retrieve in-scope domains
      const domains = await this.retrieveScope(operationId);

      if (domains.length === 0) {
        throw new Error('No in-scope domains found for operation');
      }

      console.log(`Surface Assessment Agent: Found ${domains.length} in-scope domains: ${domains.join(', ')}`);
      this.emit('scope_retrieved', { operationId, domains });

      // Step 2: Execute BBOT scan
      const scanResult = await this.executeScan(operationId, domains, userId);
      this.emit('scan_completed', scanResult);

      // Step 3: Generate and write findings to target notes
      await this.documentFindings(operationId, scanResult);
      this.emit('findings_documented', operationId);

      await this.updateAgentStatus('idle');
      this.emit('operation_completed', { operationId, scanResult });

      return scanResult;

    } catch (error) {
      console.error(`Surface Assessment Agent failed for operation ${operationId}:`, error);
      await this.updateAgentStatus('error');
      this.emit('operation_failed', { operationId, error });
      throw error;
    }
  }

  /**
   * Update agent status in database
   */
  private async updateAgentStatus(status: 'idle' | 'running' | 'error'): Promise<void> {
    if (this.agentId) {
      await db
        .update(agents)
        .set({ status, lastActivity: new Date() })
        .where(eq(agents.id, this.agentId));
    }
  }

  /**
   * Step 1: Retrieve in-scope domains from operation
   */
  async retrieveScope(operationId: string): Promise<string[]> {
    const [operation] = await db
      .select({
        scope: operations.scope,
        name: operations.name,
      })
      .from(operations)
      .where(eq(operations.id, operationId));

    if (!operation) {
      throw new Error(`Operation ${operationId} not found`);
    }

    // Parse scope field - could be comma/newline separated domains
    const scopeText = operation.scope || '';
    const domains = scopeText
      .split(/[\n,;]+/)
      .map(d => d.trim())
      .filter(d => d.length > 0)
      .filter(d => this.isValidDomain(d));

    return [...new Set(domains)]; // Deduplicate
  }

  /**
   * Validate domain format
   */
  private isValidDomain(domain: string): boolean {
    // Allow domains, IPs, and CIDR ranges
    const domainPattern = /^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
    const ipPattern = /^(\d{1,3}\.){3}\d{1,3}(\/\d{1,2})?$/;
    const wildcardPattern = /^\*\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z]{2,})+$/;

    return domainPattern.test(domain) || ipPattern.test(domain) || wildcardPattern.test(domain);
  }

  /**
   * Step 2: Execute BBOT scan
   */
  async executeScan(
    operationId: string,
    scanTargets: string[],
    userId: string
  ): Promise<ScanResult> {
    // Check concurrent scan limit
    if (this.activeScans.size >= this.config.maxConcurrentScans) {
      throw new Error(`Maximum concurrent scans (${this.config.maxConcurrentScans}) reached`);
    }

    const startTime = Date.now();

    // Configure BBOT options
    const bbotOptions = {
      preset: this.config.defaultBBOTPreset,
      modules: [],
      flags: this.config.defaultBBOTFlags,
      args: this.config.defaultBBOTArgs,
      noDeps: true,
    };

    console.log(`Surface Assessment Agent: Starting BBOT scan with preset '${bbotOptions.preset}'`);

    // Start scan
    const { scanId } = await this.bbotExecutor.startScan(
      scanTargets,
      bbotOptions,
      operationId,
      userId
    );

    this.activeScans.set(operationId, scanId);

    // Wait for scan completion (poll status)
    const result = await this.waitForScanCompletion(scanId, operationId);

    this.activeScans.delete(operationId);

    const duration = Math.round((Date.now() - startTime) / 1000);

    return {
      operationId,
      scanId,
      targets: scanTargets,
      assetsFound: result.assetsFound || 0,
      servicesFound: result.servicesFound || 0,
      vulnerabilitiesFound: result.vulnerabilitiesFound || 0,
      duration,
      status: result.status === 'completed' ? 'completed' : 'failed',
    };
  }

  /**
   * Wait for scan to complete
   */
  private async waitForScanCompletion(
    scanId: string,
    operationId: string,
    timeoutMs: number = 7200000 // 2 hours
  ): Promise<any> {
    const startTime = Date.now();
    const pollIntervalMs = 10000; // 10 seconds

    while (Date.now() - startTime < timeoutMs) {
      const [scan] = await db
        .select()
        .from(axScanResults)
        .where(eq(axScanResults.id, scanId));

      if (!scan) {
        throw new Error(`Scan ${scanId} not found`);
      }

      if (scan.status === 'completed' || scan.status === 'failed') {
        return scan;
      }

      // Emit progress
      this.emit('scan_progress', {
        operationId,
        scanId,
        status: scan.status,
        assetsFound: scan.assetsFound,
        servicesFound: scan.servicesFound,
        vulnerabilitiesFound: scan.vulnerabilitiesFound,
      });

      await new Promise(resolve => setTimeout(resolve, pollIntervalMs));
    }

    throw new Error(`Scan ${scanId} timed out after ${timeoutMs}ms`);
  }

  /**
   * Step 3: Document findings to target notes
   */
  async documentFindings(operationId: string, scanResult: ScanResult): Promise<void> {
    // Get finding summary
    const summary = await this.generateFindingSummary(operationId);

    // Generate notes content using template
    const notesContent = this.renderTemplate(this.config.findingNoteTemplate, {
      scanDate: new Date().toISOString(),
      targets: scanResult.targets.join(', '),
      duration: `${scanResult.duration} seconds`,
      totalAssets: summary.totalAssets,
      totalServices: summary.totalServices,
      totalVulnerabilities: summary.totalVulnerabilities,
      criticalCount: summary.criticalCount,
      highCount: summary.highCount,
      mediumCount: summary.mediumCount,
      lowCount: summary.lowCount,
      vulnerabilities: summary.topVulnerabilities,
    });

    // Find or create target for this operation
    const [existingTarget] = await db
      .select()
      .from(targets)
      .where(
        and(
          eq(targets.operationId, operationId),
          eq(targets.name, 'Surface Assessment Findings')
        )
      );

    if (existingTarget) {
      // Append to existing notes
      const existingDesc = existingTarget.description || '';
      const updatedDescription = `${existingDesc}\n\n---\n\n${notesContent}`;
      await db
        .update(targets)
        .set({ description: updatedDescription, updatedAt: new Date() })
        .where(eq(targets.id, existingTarget.id));
    } else {
      // Create new target with notes
      await db.insert(targets).values({
        operationId,
        name: 'Surface Assessment Findings',
        type: 'url', // Using 'url' as closest match for documentation type
        value: scanResult.targets[0] || 'assessment', // Primary target
        description: notesContent,
        priority: 1,
        tags: ['surface-assessment', 'auto-generated'],
      });
    }

    // Create individual vulnerability targets for Web Hacker Agent
    await this.createVulnerabilityTargets(operationId, summary.topVulnerabilities);
  }

  /**
   * Generate finding summary from database
   */
  private async generateFindingSummary(operationId: string): Promise<FindingSummary> {
    // Count assets
    const assets = await db
      .select()
      .from(discoveredAssets)
      .where(eq(discoveredAssets.operationId, operationId));

    // Count services
    const services = await db
      .select()
      .from(discoveredServices)
      .innerJoin(discoveredAssets, eq(discoveredServices.assetId, discoveredAssets.id))
      .where(eq(discoveredAssets.operationId, operationId));

    // Get vulnerabilities with severity breakdown
    const vulns = await db
      .select()
      .from(vulnerabilities)
      .where(eq(vulnerabilities.operationId, operationId));

    const severityCounts = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
    };

    for (const vuln of vulns) {
      const severity = (vuln.severity || 'low').toLowerCase();
      if (severity in severityCounts) {
        severityCounts[severity as keyof typeof severityCounts]++;
      }
    }

    // Get top vulnerabilities (critical and high severity)
    const topVulns = vulns
      .filter(v => ['critical', 'high'].includes((v.severity || '').toLowerCase()))
      .slice(0, 10)
      .map(v => ({
        title: v.title || 'Unknown',
        severity: v.severity || 'unknown',
        affectedAsset: (v.affectedServices as any)?.host || 'Unknown',
      }));

    return {
      totalAssets: assets.length,
      totalServices: services.length,
      totalVulnerabilities: vulns.length,
      criticalCount: severityCounts.critical,
      highCount: severityCounts.high,
      mediumCount: severityCounts.medium,
      lowCount: severityCounts.low,
      topVulnerabilities: topVulns,
    };
  }

  /**
   * Create individual targets for critical/high vulnerabilities
   * These are used by the Web Hacker Agent
   */
  private async createVulnerabilityTargets(
    operationId: string,
    vulnList: Array<{ title: string; severity: string; affectedAsset: string }>
  ): Promise<void> {
    for (const vuln of vulnList) {
      const targetName = `Vulnerability: ${vuln.title}`.substring(0, 200);

      // Check if target already exists
      const [existing] = await db
        .select()
        .from(targets)
        .where(
          and(
            eq(targets.operationId, operationId),
            eq(targets.name, targetName)
          )
        );

      if (!existing) {
        await db.insert(targets).values({
          operationId,
          name: targetName,
          type: 'url', // Using 'url' as it's the closest to vulnerability type
          value: vuln.affectedAsset || 'unknown',
          description: `Severity: ${vuln.severity}\nAsset: ${vuln.affectedAsset}\n\n[Pending Web Hacker Agent validation]`,
          priority: vuln.severity === 'critical' ? 1 : 2,
          tags: ['vulnerability', 'pending-exploitation', vuln.severity],
        });
      }
    }
  }

  /**
   * Simple template renderer
   */
  private renderTemplate(template: string, data: Record<string, any>): string {
    let result = template;

    // Handle simple variables
    for (const [key, value] of Object.entries(data)) {
      if (typeof value !== 'object' || value === null) {
        result = result.replace(new RegExp(`{{${key}}}`, 'g'), String(value ?? ''));
      }
    }

    // Handle arrays (mustache-style)
    const arrayPattern = /{{#(\w+)}}([\s\S]*?){{\/\1}}/g;
    result = result.replace(arrayPattern, (match, key, content) => {
      const arr = data[key];
      if (!Array.isArray(arr) || arr.length === 0) return '';

      return arr.map(item => {
        let itemContent = content;
        for (const [k, v] of Object.entries(item)) {
          itemContent = itemContent.replace(new RegExp(`{{${k}}}`, 'g'), String(v ?? ''));
        }
        return itemContent;
      }).join('');
    });

    return result;
  }

  /**
   * Execute handler for workflow orchestrator
   */
  static async execute(context: Record<string, any>): Promise<ScanResult> {
    const agent = new SurfaceAssessmentAgent(context.config);
    await agent.initialize();
    return agent.processOperation(context.operationId, context.userId || 'system');
  }

  /**
   * Get agent status
   */
  getStatus(): {
    agentId: string | null;
    activeScans: number;
    maxConcurrentScans: number;
  } {
    return {
      agentId: this.agentId,
      activeScans: this.activeScans.size,
      maxConcurrentScans: this.config.maxConcurrentScans,
    };
  }
}

// Singleton instance
export const surfaceAssessmentAgent = new SurfaceAssessmentAgent();

// Export execute function for dynamic import
export const execute = SurfaceAssessmentAgent.execute;
