import { BaseTaskAgent, TaskDefinition, TaskResult } from "./base-task-agent";
import { db } from "../../db";
import { vulnerabilities } from "@shared/schema";
import { eq } from "drizzle-orm";
import { agentConfig } from "../../config/agent-config";
import { getOpenAIClient, getAnthropicClient } from "../ai-clients";

/**
 * Vulnerability Agent
 * Tracks vulnerability states, generates remediation guidance,
 * analyzes CVSS scores, and manages the vulnerability lifecycle.
 */
export class VulnerabilityAgent extends BaseTaskAgent {
  constructor() {
    super("Vulnerability Agent", "vulnerability_agent", [
      "vulnerability_assessment",
      "remediation_tracking",
      "cvss_analysis",
      "severity_classification",
    ]);
  }

  async executeTask(task: TaskDefinition): Promise<TaskResult> {
    await this.updateStatus("running");

    try {
      switch (task.taskType) {
        case "analyze_vulnerabilities":
          return await this.analyzeVulnerabilities(task);
        case "generate_remediation":
          return await this.generateRemediation(task);
        case "severity_review":
          return await this.severityReview(task);
        default:
          return { success: false, error: `Unknown task type: ${task.taskType}` };
      }
    } catch (error) {
      await this.updateStatus("error");
      const errMsg = error instanceof Error ? error.message : String(error);
      return { success: false, error: errMsg };
    } finally {
      await this.updateStatus("idle");
    }
  }

  private async analyzeVulnerabilities(task: TaskDefinition): Promise<TaskResult> {
    if (!task.operationId) {
      return { success: false, error: "operationId required" };
    }

    const vulns = await db
      .select()
      .from(vulnerabilities)
      .where(eq(vulnerabilities.operationId, task.operationId));

    const analysis = {
      total: vulns.length,
      bySeverity: {
        critical: vulns.filter((v) => v.severity === "critical").length,
        high: vulns.filter((v) => v.severity === "high").length,
        medium: vulns.filter((v) => v.severity === "medium").length,
        low: vulns.filter((v) => v.severity === "low").length,
        informational: vulns.filter((v) => v.severity === "informational").length,
      },
      riskScore: this.calculateRiskScore(vulns),
    };

    await this.storeTaskMemory({
      task,
      result: { success: true, data: analysis },
      memoryType: "fact",
    });

    return { success: true, data: analysis };
  }

  private async generateRemediation(task: TaskDefinition): Promise<TaskResult> {
    const vulnId = task.parameters.vulnerabilityId;
    if (!vulnId) {
      return { success: false, error: "vulnerabilityId required in parameters" };
    }

    const [vuln] = await db
      .select()
      .from(vulnerabilities)
      .where(eq(vulnerabilities.id, vulnId))
      .limit(1);

    if (!vuln) {
      return { success: false, error: `Vulnerability ${vulnId} not found` };
    }

    // Query memory for similar vulnerabilities
    const similarMemories = await this.getRelevantMemories({
      operationId: task.operationId,
      taskType: "vulnerability_remediation",
      limit: 5,
    });

    const remediation = await this.generateRemediationGuidance(vuln, similarMemories);

    await this.storeTaskMemory({
      task,
      result: { success: true, data: { vulnId, remediation: remediation.substring(0, 200) } },
      memoryType: "insight",
    });

    return {
      success: true,
      data: {
        vulnerabilityId: vulnId,
        title: vuln.title,
        severity: vuln.severity,
        remediation,
      },
    };
  }

  private async severityReview(task: TaskDefinition): Promise<TaskResult> {
    if (!task.operationId) {
      return { success: false, error: "operationId required" };
    }

    const vulns = await db
      .select()
      .from(vulnerabilities)
      .where(eq(vulnerabilities.operationId, task.operationId));

    const reviewResults = vulns.map((vuln) => ({
      id: vuln.id,
      title: vuln.title,
      currentSeverity: vuln.severity,
      hasDescription: !!vuln.description && vuln.description.length > 20,
      hasCVSS: !!(vuln as any).cvssScore,
    }));

    return {
      success: true,
      data: {
        totalReviewed: reviewResults.length,
        results: reviewResults.slice(0, 50),
      },
    };
  }

  private calculateRiskScore(vulns: any[]): number {
    const weights = { critical: 10, high: 7, medium: 4, low: 1, informational: 0 };
    let score = 0;
    for (const vuln of vulns) {
      score += weights[vuln.severity as keyof typeof weights] || 0;
    }
    return Math.min(100, score);
  }

  private async generateRemediationGuidance(vuln: any, memories: any[]): Promise<string> {
    const contextFromMemory = memories.map((m) => m.memoryText).join("\n");

    const prompt = `Generate remediation guidance for the following vulnerability:

Title: ${vuln.title}
Severity: ${vuln.severity}
Description: ${vuln.description || "No description provided"}

${contextFromMemory ? `Context from previous findings:\n${contextFromMemory}` : ""}

Provide specific, actionable remediation steps.`;

    const config = agentConfig.taskAgent.aiModel;
    const anthropic = getAnthropicClient();
    const openai = getOpenAIClient();

    try {
      if (config.provider === "anthropic" && anthropic) {
        const response = await anthropic.messages.create({
          model: config.model,
          max_tokens: 1024,
          temperature: 0.3,
          messages: [{ role: "user", content: prompt }],
        });
        const block = response.content[0];
        return block.type === "text" ? block.text : "Unable to generate remediation guidance.";
      }

      if (openai) {
        const response = await openai.chat.completions.create({
          model: "gpt-5.2-chat-latest",
          max_tokens: 1024,
          temperature: 0.3,
          messages: [{ role: "user", content: prompt }],
        });
        return response.choices[0]?.message?.content || "Unable to generate remediation guidance.";
      }
    } catch (error) {
      console.error("[VulnerabilityAgent] AI generation failed:", error);
    }

    return `Remediation for ${vuln.title} (${vuln.severity}): Review the vulnerability and apply appropriate patches or configuration changes.`;
  }
}

export const vulnerabilityAgent = new VulnerabilityAgent();
