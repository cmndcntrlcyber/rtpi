import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';
import { db } from '../db';
import { empireListeners } from '@shared/schema';
import { eq } from 'drizzle-orm';

const execAsync = promisify(exec);

/**
 * Kasm Nginx Configuration Manager
 *
 * Manages dynamic nginx proxy routes for Empire C2 listeners.
 * Creates subdomain configurations that route external implant connections
 * through the Kasm nginx proxy to Empire listeners.
 *
 * Architecture:
 * External Implant → Cloudflare (optional) → Kasm Nginx Proxy → Empire Listener
 *
 * Example Route:
 * listener-abc123.kasm.attck.nexus:8443 → http://empire:8080
 */

export interface ProxyRoute {
  subdomain: string;
  port: number;
  target: string;
  ssl?: boolean;
  listenerId?: string;
}

export interface ProxyConfig {
  subdomain: string;
  targetHost: string;
  targetPort: number;
  ssl: boolean;
  certPath?: string;
  keyPath?: string;
}

export class KasmNginxManager {
  private configPath: string;
  private nginxContainer: string;
  private kasmDomain: string;
  private enabled: boolean;

  constructor(options?: {
    configPath?: string;
    nginxContainer?: string;
    kasmDomain?: string;
    enabled?: boolean;
  }) {
    this.configPath = options?.configPath || '/etc/nginx/conf.d';
    this.nginxContainer = options?.nginxContainer || 'kasm-proxy';
    this.kasmDomain = options?.kasmDomain || 'kasm.attck.nexus';
    this.enabled = options?.enabled ?? (process.env.KASM_PROXY_ENABLED === 'true');
  }

  /**
   * Register a dynamic proxy route for an Empire listener
   */
  async registerListenerProxy(listenerId: string, listenerPort: number, listenerName: string): Promise<ProxyRoute | null> {
    if (!this.enabled) {
      console.log('[KasmNginxManager] Kasm proxy disabled, skipping route registration');
      return null;
    }

    try {
      // Generate unique subdomain based on listener ID
      const subdomain = `listener-${listenerId.slice(0, 8)}.${this.kasmDomain}`;
      const targetHost = process.env.EMPIRE_HOST || 'empire';
      const proxyPort = 8443;

      const route: ProxyRoute = {
        subdomain,
        port: proxyPort,
        target: `http://${targetHost}:${listenerPort}`,
        ssl: true,
        listenerId,
      };

      // Generate nginx configuration
      const nginxConfig = this.generateNginxConfig({
        subdomain,
        targetHost,
        targetPort: listenerPort,
        ssl: true,
      });

      // Write configuration file
      const configFileName = `empire-listener-${listenerId}.conf`;
      await this.writeNginxConfig(configFileName, nginxConfig);

      // Reload nginx to apply changes
      await this.reloadNginx();

      console.log(`[KasmNginxManager] Registered proxy route: ${subdomain}:${proxyPort} → ${route.target}`);

      // Update listener record with proxy information
      await db
        .update(empireListeners)
        .set({
          config: {
            proxyRoute: route,
            proxySubdomain: subdomain,
            proxyPort,
          },
        })
        .where(eq(empireListeners.id, listenerId));

      return route;
    } catch (error) {
      console.error('[KasmNginxManager] Failed to register proxy route:', error);
      throw error;
    }
  }

  /**
   * Unregister a proxy route for an Empire listener
   */
  async unregisterListenerProxy(listenerId: string): Promise<void> {
    if (!this.enabled) {
      return;
    }

    try {
      const configFileName = `empire-listener-${listenerId}.conf`;
      await this.removeNginxConfig(configFileName);
      await this.reloadNginx();

      console.log(`[KasmNginxManager] Unregistered proxy route for listener ${listenerId}`);
    } catch (error) {
      console.error('[KasmNginxManager] Failed to unregister proxy route:', error);
      throw error;
    }
  }

  /**
   * Generate nginx configuration for a proxy route
   */
  private generateNginxConfig(config: ProxyConfig): string {
    const { subdomain, targetHost, targetPort, ssl, certPath, keyPath } = config;

    const sslConfig = ssl
      ? `
    ssl_certificate ${certPath || '/etc/nginx/ssl/kasm.crt'};
    ssl_certificate_key ${keyPath || '/etc/nginx/ssl/kasm.key'};
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
`
      : '';

    const listenPort = ssl ? '8443 ssl' : '80';

    return `# Dynamic proxy route for Empire C2 listener
# Generated by RTPI Kasm Nginx Manager
# Subdomain: ${subdomain}
# Target: ${targetHost}:${targetPort}

server {
    listen ${listenPort};
    server_name ${subdomain};
${sslConfig}
    # Proxy settings
    location / {
        proxy_pass http://${targetHost}:${targetPort};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # WebSocket support (for Empire C2 traffic)
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";

        # Timeouts for long-polling C2 traffic
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        # Buffer settings
        proxy_buffering off;
        proxy_request_buffering off;
    }

    # Health check endpoint
    location /health {
        access_log off;
        return 200 "healthy\\n";
        add_header Content-Type text/plain;
    }
}
`;
  }

  /**
   * Write nginx configuration file
   */
  private async writeNginxConfig(filename: string, content: string): Promise<void> {
    if (!this.enabled) {
      return;
    }

    try {
      const configFilePath = path.join(this.configPath, filename);

      // Check if running in Docker container
      if (await this.isNginxContainerized()) {
        // Write to container using docker exec
        const escapedContent = content.replace(/"/g, '\\"');
        await execAsync(`docker exec ${this.nginxContainer} sh -c "echo \\"${escapedContent}\\" > ${configFilePath}"`);
      } else {
        // Write directly to filesystem (development mode)
        await fs.writeFile(configFilePath, content, 'utf8');
      }

      console.log(`[KasmNginxManager] Wrote nginx config: ${filename}`);
    } catch (error) {
      console.error('[KasmNginxManager] Failed to write nginx config:', error);
      throw error;
    }
  }

  /**
   * Remove nginx configuration file
   */
  private async removeNginxConfig(filename: string): Promise<void> {
    if (!this.enabled) {
      return;
    }

    try {
      const configFilePath = path.join(this.configPath, filename);

      if (await this.isNginxContainerized()) {
        await execAsync(`docker exec ${this.nginxContainer} rm -f ${configFilePath}`);
      } else {
        await fs.unlink(configFilePath);
      }

      console.log(`[KasmNginxManager] Removed nginx config: ${filename}`);
    } catch (error) {
      console.error('[KasmNginxManager] Failed to remove nginx config:', error);
      throw error;
    }
  }

  /**
   * Reload nginx to apply configuration changes
   */
  private async reloadNginx(): Promise<void> {
    if (!this.enabled) {
      return;
    }

    try {
      if (await this.isNginxContainerized()) {
        await execAsync(`docker exec ${this.nginxContainer} nginx -s reload`);
      } else {
        await execAsync('nginx -s reload');
      }

      console.log('[KasmNginxManager] Reloaded nginx configuration');
    } catch (error) {
      console.error('[KasmNginxManager] Failed to reload nginx:', error);
      throw error;
    }
  }

  /**
   * Check if nginx is running in a Docker container
   */
  private async isNginxContainerized(): Promise<boolean> {
    try {
      await execAsync(`docker ps -q -f name=${this.nginxContainer}`);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Verify nginx configuration is valid
   */
  async testConfiguration(): Promise<boolean> {
    if (!this.enabled) {
      return true;
    }

    try {
      if (await this.isNginxContainerized()) {
        await execAsync(`docker exec ${this.nginxContainer} nginx -t`);
      } else {
        await execAsync('nginx -t');
      }
      return true;
    } catch (error) {
      console.error('[KasmNginxManager] Nginx configuration test failed:', error);
      return false;
    }
  }

  /**
   * List all active proxy routes
   */
  async listProxyRoutes(): Promise<ProxyRoute[]> {
    if (!this.enabled) {
      return [];
    }

    try {
      const listeners = await db.query.empireListeners.findMany();
      const routes: ProxyRoute[] = [];

      for (const listener of listeners) {
        if (listener.config && (listener.config as any).proxyRoute) {
          routes.push((listener.config as any).proxyRoute);
        }
      }

      return routes;
    } catch (error) {
      console.error('[KasmNginxManager] Failed to list proxy routes:', error);
      return [];
    }
  }
}

// Export singleton instance
export const kasmNginxManager = new KasmNginxManager({
  enabled: process.env.KASM_PROXY_ENABLED === 'true',
  nginxContainer: process.env.KASM_NGINX_CONTAINER || 'kasm-proxy',
  kasmDomain: process.env.KASM_DOMAIN || 'kasm.attck.nexus',
});
