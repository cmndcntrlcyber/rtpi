import { db } from "../db";
import { agents, mcpServers, vulnerabilities, vulnerabilityVersions } from "@shared/schema";
import { eq } from "drizzle-orm";
import { ollamaAIClient } from "./ollama-ai-client";

interface EnrichmentContext {
  cveId?: string;
  cweId?: string;
  title?: string;
  targetInfo?: any;
  operationScope?: string;
}

interface EnrichmentResult {
  field: string;
  content: string;
  confidence: number;
  sources: string[];
}

/**
 * AI-powered vulnerability enrichment service
 * Uses Tavily MCP for research and AI agents for content synthesis
 */
export class VulnerabilityAIEnrichment {
  /**
   * Enrich vulnerability from CVE database
   */
  async enrichFromCVE(cveId: string): Promise<{
    description?: string;
    severity?: string;
    cvssVector?: string;
    cvssScore?: number;
    references?: string[];
    cweId?: string;
  }> {
    try {
      // Find an active agent with Tavily MCP access
      const agent = await this.getAgentWithTavily();
      if (!agent) {
        console.warn("No agent with Tavily MCP found for CVE enrichment");
        return {};
      }

      // Search for CVE information using Tavily
      const searchQuery = `${cveId} vulnerability details CVSS score impact affected systems`;
      const searchResults = await this.tavilySearch(agent.id, searchQuery, {
        max_results: 5,
        include_raw_content: true,
        search_depth: "advanced",
      });

      if (!searchResults || searchResults.length === 0) {
        return {};
      }

      // Use AI to synthesize the information
      const synthesized = await this.synthesizeWithAI(agent.id, {
        task: "extract_cve_data",
        cveId,
        searchResults,
      });

      return synthesized;
    } catch (error) {
      console.error("CVE enrichment error:", error);
      return {};
    }
  }

  /**
   * Generate Proof of Concept based on vulnerability context
   */
  async generatePOC(context: EnrichmentContext): Promise<EnrichmentResult | null> {
    try {
      const agent = await this.getAgentWithTavily();
      if (!agent) return null;

      // Build search query
      let query = "";
      if (context.cveId) {
        query = `${context.cveId} proof of concept exploit example demonstration`;
      } else if (context.cweId) {
        query = `${context.cweId} exploitation example proof of concept`;
      } else if (context.title) {
        query = `${context.title} vulnerability proof of concept exploit`;
      }

      if (!query) return null;

      // Search for POC examples
      const searchResults = await this.tavilySearch(agent.id, query, {
        max_results: 5,
        include_raw_content: true,
      });

      // Synthesize POC from results
      const poc = await this.synthesizeWithAI(agent.id, {
        task: "generate_poc",
        context,
        searchResults,
        targetInfo: context.targetInfo,
      });

      return {
        field: "proofOfConcept",
        content: poc.content || "",
        confidence: poc.confidence || 0.7,
        sources: poc.sources || [],
      };
    } catch (error) {
      console.error("POC generation error:", error);
      return null;
    }
  }

  /**
   * Suggest remediation steps for vulnerability
   */
  async suggestRemediation(context: EnrichmentContext): Promise<EnrichmentResult | null> {
    try {
      const agent = await this.getAgentWithTavily();
      if (!agent) return null;

      // Build search query
      let query = "";
      if (context.cveId) {
        query = `${context.cveId} remediation mitigation fix patch solution`;
      } else if (context.cweId) {
        query = `${context.cweId} mitigation remediation best practices secure coding`;
      } else if (context.title) {
        query = `${context.title} vulnerability fix remediation solution`;
      }

      if (!query) return null;

      // Search for remediation guidance
      const searchResults = await this.tavilySearch(agent.id, query, {
        max_results: 5,
        include_raw_content: true,
      });

      // Synthesize remediation steps
      const remediation = await this.synthesizeWithAI(agent.id, {
        task: "generate_remediation",
        context,
        searchResults,
      });

      return {
        field: "remediation",
        content: remediation.content || "",
        confidence: remediation.confidence || 0.8,
        sources: remediation.sources || [],
      };
    } catch (error) {
      console.error("Remediation generation error:", error);
      return null;
    }
  }

  /**
   * Generate detailed description from CVE/CWE
   */
  async generateDescription(context: EnrichmentContext): Promise<EnrichmentResult | null> {
    try {
      const agent = await this.getAgentWithTavily();
      if (!agent) return null;

      let query = "";
      if (context.cveId) {
        query = `${context.cveId} vulnerability description technical details impact`;
      } else if (context.cweId) {
        query = `${context.cweId} weakness description examples impact`;
      }

      if (!query) return null;

      const searchResults = await this.tavilySearch(agent.id, query, {
        max_results: 3,
        include_raw_content: true,
      });

      const description = await this.synthesizeWithAI(agent.id, {
        task: "generate_description",
        context,
        searchResults,
      });

      return {
        field: "description",
        content: description.content || "",
        confidence: description.confidence || 0.85,
        sources: description.sources || [],
      };
    } catch (error) {
      console.error("Description generation error:", error);
      return null;
    }
  }

  /**
   * Auto-calculate CVSS score from vulnerability data
   */
  async calculateCVSS(vulnData: any): Promise<{
    cvssVector?: string;
    cvssScore?: number;
  }> {
    try {
      const agent = await this.getActiveAgent();
      if (!agent) return {};

      // Use AI to suggest CVSS metrics based on description
      const analysis = await this.synthesizeWithAI(agent.id, {
        task: "calculate_cvss",
        vulnerabilityData: vulnData,
      });

      return {
        cvssVector: analysis.cvssVector,
        cvssScore: analysis.cvssScore,
      };
    } catch (error) {
      console.error("CVSS calculation error:", error);
      return {};
    }
  }

  /**
   * Find related vulnerabilities in the database
   */
  async findRelatedFindings(vulnerabilityId: string): Promise<any[]> {
    try {
      // Get the vulnerability
      const vuln = await db
        .select()
        .from(vulnerabilities)
        .where(eq(vulnerabilities.id, vulnerabilityId))
        .limit(1)
        .then((rows) => rows[0]);

      if (!vuln) return [];

      // Find similar vulnerabilities (simple implementation - can be enhanced)
      const related = await db
        .select()
        .from(vulnerabilities)
        .where(eq(vulnerabilities.cweId, vuln.cweId || ""))
        .limit(5);

      return related.filter((v) => v.id !== vulnerabilityId);
    } catch (error) {
      console.error("Find related findings error:", error);
      return [];
    }
  }

  /**
   * Generate all empty fields for a vulnerability
   */
  async enrichAllFields(
    vulnerabilityId: string,
    userId: string
  ): Promise<{
    enriched: Record<string, any>;
    aiGenerated: Record<string, boolean>;
  }> {
    try {
      // Get vulnerability
      const vuln = await db
        .select()
        .from(vulnerabilities)
        .where(eq(vulnerabilities.id, vulnerabilityId))
        .limit(1)
        .then((rows) => rows[0]);

      if (!vuln) {
        throw new Error("Vulnerability not found");
      }

      const context: EnrichmentContext = {
        cveId: vuln.cveId || undefined,
        cweId: vuln.cweId || undefined,
        title: vuln.title,
      };

      const enriched: Record<string, any> = {};
      const aiGenerated: Record<string, boolean> = {};

      // Enrich description if empty
      if (!vuln.description || vuln.description.trim() === "") {
        const descResult = await this.generateDescription(context);
        if (descResult) {
          enriched.description = descResult.content;
          aiGenerated.description = true;
        }
      }

      // Enrich POC if empty
      if (!vuln.proofOfConcept || vuln.proofOfConcept.trim() === "") {
        const pocResult = await this.generatePOC(context);
        if (pocResult) {
          enriched.proofOfConcept = pocResult.content;
          aiGenerated.proofOfConcept = true;
        }
      }

      // Enrich remediation if empty
      if (!vuln.remediation || vuln.remediation.trim() === "") {
        const remResult = await this.suggestRemediation(context);
        if (remResult) {
          enriched.remediation = remResult.content;
          aiGenerated.remediation = true;
        }
      }

      // Enrich CVE data if CVE ID provided but data missing
      if (vuln.cveId && (!vuln.cvssVector || !vuln.cvssScore)) {
        const cveData = await this.enrichFromCVE(vuln.cveId);
        if (cveData.cvssVector) {
          enriched.cvssVector = cveData.cvssVector;
          aiGenerated.cvssVector = true;
        }
        if (cveData.cvssScore) {
          enriched.cvssScore = cveData.cvssScore;
          aiGenerated.cvssScore = true;
        }
        if (cveData.references && cveData.references.length > 0) {
          enriched.references = cveData.references;
          aiGenerated.references = true;
        }
      }

      // Save version history
      await db.insert(vulnerabilityVersions).values({
        vulnerabilityId,
        data: { enriched, aiGenerated },
        changedBy: userId,
        changeDescription: "AI-powered field enrichment",
        changeType: "ai_generation",
      });

      return { enriched, aiGenerated };
    } catch (error) {
      console.error("Enrich all fields error:", error);
      throw error;
    }
  }

  /**
   * Get an active agent with Tavily MCP access
   */
  private async getAgentWithTavily(): Promise<any> {
    try {
      const allAgents = await db.select().from(agents);

      for (const agent of allAgents) {
        const config = agent.config as any;
        if (config?.mcpServerId) {
          const mcpServer = await db
            .select()
            .from(mcpServers)
            .where(eq(mcpServers.id, config.mcpServerId))
            .limit(1)
            .then((rows) => rows[0]);

          if (mcpServer && mcpServer.command.includes("tavily")) {
            return agent;
          }
        }
      }

      return null;
    } catch (error) {
      console.error("Get agent with Tavily error:", error);
      return null;
    }
  }

  /**
   * Get any active agent for AI synthesis
   */
  private async getActiveAgent(): Promise<any> {
    try {
      const activeAgents = await db
        .select()
        .from(agents)
        .where(eq(agents.status, "idle"))
        .limit(1);

      return activeAgents[0] || null;
    } catch (error) {
      console.error("Get active agent error:", error);
      return null;
    }
  }

  /**
   * Perform Tavily search via MCP
   */
  private async tavilySearch(
    agentId: string,
    query: string,
    _options: any = {}
  ): Promise<any[]> {
    try {
      // This would integrate with your actual MCP infrastructure
      // For now, return mock data structure
      console.log(`[Tavily Search] Agent ${agentId}: ${query}`);

      // In production, this would call your MCP server manager
      // const results = await mcpServerManager.callTool(agentId, 'tavily-search', { query, ...options });

      // Mock response structure
      return [
        {
          title: `CVE Database Entry for ${query}`,
          url: `https://nvd.nist.gov/vuln/detail/${query}`,
          content: "Detailed vulnerability information...",
          score: 0.95,
        },
      ];
    } catch (error) {
      console.error("Tavily search error:", error);
      return [];
    }
  }

  /**
   * Synthesize information using AI (now using real Ollama models!)
   */
  private async synthesizeWithAI(agentId: string, params: any): Promise<any> {
    try {
      console.log(`[AI Synthesis] Agent ${agentId}: ${params.task}`);

      // Use Ollama AI Client with prompt templates
      const messages = ollamaAIClient.applyTemplate(params.task, params);

      const response = await ollamaAIClient.complete(messages, {
        temperature: 0.7,
        maxTokens: 2048,
        useCache: true,
        enrichmentType: params.task,
      });

      if (!response.success) {
        console.error(`[AI Synthesis] Failed: ${response.error}`);
        return this.getFallbackResponse(params.task, params);
      }

      // Parse response based on task type
      return this.parseAIResponse(params.task, response.content, params);
    } catch (error) {
      console.error("AI synthesis error:", error);
      // Return fallback mock data if AI fails
      return this.getFallbackResponse(params.task, params);
    }
  }

  /**
   * Parse AI response based on task type
   */
  private parseAIResponse(task: string, content: string, params: any): any {
    switch (task) {
      case "extract_cve_data":
        try {
          // Try to parse JSON response
          const parsed = JSON.parse(content);
          return parsed;
        } catch {
          // If not JSON, extract from text
          return {
            description: content,
            severity: "medium",
            references: params.searchResults?.map((r: any) => r.url) || [],
          };
        }

      case "generate_poc":
        return {
          content,
          confidence: 0.8,
          sources: params.searchResults?.map((r: any) => r.url) || [],
        };

      case "generate_remediation":
        return {
          content,
          confidence: 0.85,
          sources: params.searchResults?.map((r: any) => r.url) || [],
        };

      case "generate_description":
        return {
          content,
          confidence: 0.85,
          sources: params.searchResults?.map((r: any) => r.url) || [],
        };

      case "calculate_cvss":
        try {
          const parsed = JSON.parse(content);
          return {
            cvssVector: parsed.cvssVector,
            cvssScore: parsed.cvssScore,
          };
        } catch {
          return {
            cvssVector: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",
            cvssScore: 5.0,
          };
        }

      default:
        return { content };
    }
  }

  /**
   * Fallback responses if AI is unavailable
   */
  private getFallbackResponse(task: string, params: any): any {
    switch (task) {
      case "extract_cve_data":
        return {
          description: `CVE information for ${params.cveId} (AI enrichment unavailable - using fallback)`,
          severity: "medium",
          references: params.searchResults?.map((r: any) => r.url) || [],
        };

      case "generate_poc":
        return {
          content: `Proof of concept for this vulnerability is pending AI generation. Please try again when Ollama service is available.`,
          confidence: 0.1,
          sources: [],
        };

      case "generate_remediation":
        return {
          content: `Remediation steps are pending AI generation. Please try again when Ollama service is available.`,
          confidence: 0.1,
          sources: [],
        };

      case "generate_description":
        return {
          content: `Vulnerability description is pending AI generation. Please try again when Ollama service is available.`,
          confidence: 0.1,
          sources: [],
        };

      case "calculate_cvss":
        return {
          cvssVector: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",
          cvssScore: 5.0,
        };

      default:
        return {};
    }
  }
}

// Export singleton instance
export const vulnerabilityAIEnrichment = new VulnerabilityAIEnrichment();
