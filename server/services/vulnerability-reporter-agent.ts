/**
 * Vulnerability Reporter Agent
 *
 * A specialized reporter that monitors vulnerability state changes,
 * detects new critical/high findings, and reports to the Operations Manager.
 * Follows the existing ReporterAgentService polling pattern.
 */

import { EventEmitter } from 'events';
import { db } from '../db';
import { vulnerabilities, agents, reporters, users } from '@shared/schema';
import { eq, and, gt, desc, sql } from 'drizzle-orm';

// ============================================================================
// Types
// ============================================================================

interface VulnReporterConfig {
  pollIntervalMs: number;           // Default: 60000 (1 minute)
  criticalAlertImmediate: boolean;  // Submit question immediately for criticals
  trackStatusChanges: boolean;      // Detect open->fixed, etc.
}

export interface VulnChangeEvent {
  type: 'new_vulnerability' | 'severity_changed' | 'status_changed' | 'remediated';
  vulnerabilityId: string;
  operationId: string;
  severity: string;
  title: string;
  previousValue?: string;
  newValue?: string;
  timestamp: Date;
}

// ============================================================================
// Service
// ============================================================================

class VulnerabilityReporterAgent extends EventEmitter {
  private lastPollTimestamp: Date;
  private pollInterval: NodeJS.Timeout | null = null;
  private reporterId: string | null = null;
  private agentId: string | null = null;
  private _isPolling: boolean = false;
  private eventsDetected: number = 0;

  private config: VulnReporterConfig = {
    pollIntervalMs: 60000,
    criticalAlertImmediate: true,
    trackStatusChanges: true,
  };

  constructor() {
    super();
    this.lastPollTimestamp = new Date();
  }

  /**
   * Initialize the vulnerability reporter agent.
   * Creates agent and reporter records in the database.
   */
  async initialize(): Promise<void> {
    try {
      // Find or create agent record
      const existingAgents = await db
        .select()
        .from(agents)
        .where(eq(agents.name, 'Vulnerability Reporter Agent'))
        .limit(1);

      if (existingAgents.length > 0) {
        this.agentId = existingAgents[0].id;
      } else {
        const [newAgent] = await db
          .insert(agents)
          .values({
            name: 'Vulnerability Reporter Agent',
            type: 'custom',
            status: 'idle',
            capabilities: ['vulnerability_monitoring', 'severity_detection', 'status_tracking'],
            config: {
              systemPrompt: 'Monitor vulnerability discoveries and report critical findings to the Operations Manager.',
              model: 'system',
            },
          })
          .returning();
        this.agentId = newAgent.id;
      }

      // Find or create reporter record
      const existingReporters = await db
        .select()
        .from(reporters)
        .where(eq(reporters.pageId, 'vulnerabilities'))
        .limit(1);

      if (existingReporters.length > 0) {
        this.reporterId = existingReporters[0].id;
      } else {
        // Look up admin user for createdBy (admin is always created before agents)
        const adminUsers = await db
          .select()
          .from(users)
          .where(eq(users.role, 'admin'))
          .limit(1);

        if (adminUsers.length === 0) {
          console.warn('[VulnReporter] No admin user found, cannot create reporter');
          return;
        }

        const [newReporter] = await db
          .insert(reporters)
          .values({
            name: 'Vulnerability Reporter',
            agentId: this.agentId,
            pageId: 'vulnerabilities',
            status: 'idle',
            pollIntervalMs: this.config.pollIntervalMs,
            config: this.config as any,
            createdBy: adminUsers[0].id,
          })
          .returning();
        this.reporterId = newReporter.id;
      }

      console.log(`[VulnReporter] Initialized: agentId=${this.agentId}, reporterId=${this.reporterId}`);
    } catch (error) {
      console.error('[VulnReporter] Initialization failed:', error);
    }
  }

  /**
   * Start the polling loop.
   */
  async startPolling(): Promise<void> {
    if (this._isPolling) {
      console.log('[VulnReporter] Already polling');
      return;
    }

    this._isPolling = true;
    this.lastPollTimestamp = new Date();

    // Update reporter status
    if (this.reporterId) {
      await db
        .update(reporters)
        .set({ status: 'active' })
        .where(eq(reporters.id, this.reporterId));
    }

    this.pollInterval = setInterval(() => {
      this.pollVulnerabilities().catch(err => {
        console.error('[VulnReporter] Poll error:', err);
      });
    }, this.config.pollIntervalMs);

    console.log(`[VulnReporter] Polling started (every ${this.config.pollIntervalMs}ms)`);
  }

  /**
   * Stop the polling loop.
   */
  async stopPolling(): Promise<void> {
    if (this.pollInterval) {
      clearInterval(this.pollInterval);
      this.pollInterval = null;
    }

    this._isPolling = false;

    // Update reporter status
    if (this.reporterId) {
      await db
        .update(reporters)
        .set({ status: 'idle' })
        .where(eq(reporters.id, this.reporterId));
    }

    console.log('[VulnReporter] Polling stopped');
  }

  /**
   * Check if currently polling.
   */
  isPolling(): boolean {
    return this._isPolling;
  }

  /**
   * Trigger an immediate poll (used by pipeline cascade).
   */
  async pollNow(): Promise<VulnChangeEvent[]> {
    return this.pollVulnerabilities();
  }

  /**
   * Main polling loop.
   * Queries for new vulnerabilities and status changes since last poll.
   */
  private async pollVulnerabilities(): Promise<VulnChangeEvent[]> {
    const events: VulnChangeEvent[] = [];

    try {
      // Detect new vulnerabilities since last poll
      const newVulns = await this.detectNewVulnerabilities(this.lastPollTimestamp);
      events.push(...newVulns);

      // Detect status changes since last poll
      if (this.config.trackStatusChanges) {
        const statusChanges = await this.detectStatusChanges(this.lastPollTimestamp);
        events.push(...statusChanges);
      }

      // Submit reports for critical/high findings
      if (events.length > 0) {
        await this.submitReportToOpsManager(events);
        this.eventsDetected += events.length;
        this.emit('vulnerability_report_submitted', { events, count: events.length });
      }

      // Update last poll timestamp
      this.lastPollTimestamp = new Date();

      // Update reporter status
      if (this.reporterId) {
        await db
          .update(reporters)
          .set({
            lastPollAt: new Date(),
            status: 'active',
          })
          .where(eq(reporters.id, this.reporterId));
      }
    } catch (error) {
      console.error('[VulnReporter] Poll failed:', error);
    }

    return events;
  }

  /**
   * Detect new vulnerabilities discovered since the given timestamp.
   */
  private async detectNewVulnerabilities(since: Date): Promise<VulnChangeEvent[]> {
    const events: VulnChangeEvent[] = [];

    try {
      const newVulns = await db
        .select()
        .from(vulnerabilities)
        .where(gt(vulnerabilities.discoveredAt, since))
        .orderBy(desc(vulnerabilities.discoveredAt));

      for (const vuln of newVulns) {
        // Only report critical and high severity vulnerabilities
        if (vuln.severity === 'critical' || vuln.severity === 'high') {
          events.push({
            type: 'new_vulnerability',
            vulnerabilityId: vuln.id,
            operationId: vuln.operationId || '',
            severity: vuln.severity,
            title: vuln.title,
            timestamp: vuln.discoveredAt,
          });
        }
      }
    } catch (error) {
      console.error('[VulnReporter] Error detecting new vulnerabilities:', error);
    }

    return events;
  }

  /**
   * Detect vulnerability status changes since the given timestamp.
   */
  private async detectStatusChanges(since: Date): Promise<VulnChangeEvent[]> {
    const events: VulnChangeEvent[] = [];

    try {
      // Find vulnerabilities updated since last poll that have been remediated
      const updatedVulns = await db
        .select()
        .from(vulnerabilities)
        .where(
          and(
            gt(vulnerabilities.updatedAt, since),
            sql`${vulnerabilities.status} != 'open'`
          )
        );

      for (const vuln of updatedVulns) {
        if (vuln.status === 'fixed' || vuln.status === 'remediated') {
          events.push({
            type: 'remediated',
            vulnerabilityId: vuln.id,
            operationId: vuln.operationId || '',
            severity: vuln.severity,
            title: vuln.title,
            previousValue: 'open',
            newValue: vuln.status,
            timestamp: vuln.updatedAt,
          });
        } else {
          events.push({
            type: 'status_changed',
            vulnerabilityId: vuln.id,
            operationId: vuln.operationId || '',
            severity: vuln.severity,
            title: vuln.title,
            previousValue: 'open',
            newValue: vuln.status,
            timestamp: vuln.updatedAt,
          });
        }
      }
    } catch (error) {
      console.error('[VulnReporter] Error detecting status changes:', error);
    }

    return events;
  }

  /**
   * Submit vulnerability reports to the Operations Manager via the reporter infrastructure.
   */
  private async submitReportToOpsManager(events: VulnChangeEvent[]): Promise<void> {
    if (!this.reporterId) {
      console.warn('[VulnReporter] No reporterId, cannot submit report');
      return;
    }

    try {
      const { reporterAgentService } = await import('./reporter-agent-service');

      // Group events by type for a consolidated report
      const criticalVulns = events.filter(e => e.type === 'new_vulnerability' && e.severity === 'critical');
      const highVulns = events.filter(e => e.type === 'new_vulnerability' && e.severity === 'high');
      const remediatedVulns = events.filter(e => e.type === 'remediated');
      const statusChanges = events.filter(e => e.type === 'status_changed');

      // Submit critical vulnerabilities as high-priority questions
      for (const vuln of criticalVulns) {
        await reporterAgentService.submitQuestion({
          reporterId: this.reporterId,
          question: `CRITICAL vulnerability detected: "${vuln.title}" in operation ${vuln.operationId}. Immediate attention required. What action should be taken?`,
          context: {
            vulnerabilityId: vuln.vulnerabilityId,
            severity: vuln.severity,
            operationId: vuln.operationId,
            detectedAt: vuln.timestamp.toISOString(),
          },
          priority: 10,
        });
      }

      // Submit high vulnerabilities as elevated-priority questions
      for (const vuln of highVulns) {
        await reporterAgentService.submitQuestion({
          reporterId: this.reporterId,
          question: `HIGH severity vulnerability detected: "${vuln.title}" in operation ${vuln.operationId}. Review and prioritize remediation.`,
          context: {
            vulnerabilityId: vuln.vulnerabilityId,
            severity: vuln.severity,
            operationId: vuln.operationId,
            detectedAt: vuln.timestamp.toISOString(),
          },
          priority: 8,
        });
      }

      // Submit a summary for remediations (lower priority)
      if (remediatedVulns.length > 0) {
        await reporterAgentService.submitQuestion({
          reporterId: this.reporterId,
          question: `${remediatedVulns.length} vulnerabilities have been remediated. Confirm and update assessment status.`,
          context: {
            remediatedCount: remediatedVulns.length,
            vulnerabilities: remediatedVulns.map(v => ({
              id: v.vulnerabilityId,
              title: v.title,
              severity: v.severity,
            })),
          },
          priority: 3,
        });
      }

      console.log(
        `[VulnReporter] Submitted reports: ${criticalVulns.length} critical, ${highVulns.length} high, ${remediatedVulns.length} remediated, ${statusChanges.length} status changes`
      );
    } catch (error) {
      console.error('[VulnReporter] Failed to submit reports:', error);
    }
  }

  /**
   * Get current status of the reporter.
   */
  async getStatus(): Promise<{
    isPolling: boolean;
    lastPoll: Date;
    eventsDetected: number;
    reporterId: string | null;
    agentId: string | null;
  }> {
    return {
      isPolling: this._isPolling,
      lastPoll: this.lastPollTimestamp,
      eventsDetected: this.eventsDetected,
      reporterId: this.reporterId,
      agentId: this.agentId,
    };
  }
}

export const vulnerabilityReporterAgent = new VulnerabilityReporterAgent();
export default vulnerabilityReporterAgent;
